<html lang="{{ site.lang | default: "en-US" }}"`>
    <head>
        <meta charset="utf-8">
        <meta http-equiv="X-UA-Compatible" content="IE=edge">

        <link rel="stylesheet" href="metaug_js/tf.css">
        <script src="assets/js/scale.fix.js"></script>
        <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no">

        <script type="text/javascript" src="https://www.gstatic.com/charts/loader.js"></script>
        <link rel="stylesheet" type="text/css" href="google_chart.css">

		<script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs@1.0.0/dist/tf.min.js"></script>
		<script src="metaug_js/math.js"></script>

        <!--[if lt IE 9]>
        <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
        <![endif]-->
    </head>

<body>
	<div class="contentwrapper">
	<section>
	<h1 style="text-align:center">Imparting universal linguistic inductive biases via meta-learning</h1>


	<h2>Introduction</h2>

	<p>Language acquisition involves a complex interplay between the data and the learner. The importance of data is clear: we can only learn a language if we have experience with it. Less obviously, acquisition is also guided by properties of the learner called <b>inductive biases</b>, which determine how the learner will generalize beyond the utterances they have encountered. As an example, consider the following pattern:</p>

	<ul>
		<li>gbg &rarr; .ga.ba.ga.</li>
		<li>qq &rarr; .qa.qa.</li>
		<li>tlv &rarr; ???</li>
	</ul>


	<p>What output should replace the question marks? You probably answered <em>.ta.la.va.</em> even though other answers are conceivable; e.g., the provided outputs are consistent with a rule that involves reversing the input, so the answer could instead be <em>.va.la.ta.</em> If you answered <em>.ta.la.va.</em> instead of <em>.va.la.ta.</em>, it suggests that you have an inductive bias for preserving the input order.</p>

	<p>Which inductive biases enable humans to acquire language? The answer is hotly debated. To facilitate computational modeling of this question, we introduce a framework for giving particular linguistic inductive biases to a model. Such a model can then be used to explore the effects of those inductive biases, and to see which biases yield the most human-like learning.</p>

	<p>In our framework, the inductive biases are encoded in the initial state of a neural network. This initial state is found with <b>meta-learning</b>, a technique through which a model discovers how to acquire new languages more easily via exposure to many possible languages. By controlling the properties of the languages that are used during meta-learning, we can control the set of inductive biases that meta-learning imparts.</p>


	<h2>Try it out!</h2>

	<p>To demonstrate this framework, we use the linguistic phenomenon of syllable structure.  For a given language, the model must learn how to map a sequence of sounds (e.g., <em>talava</em>)  into a sequence of syllables (e.g., <em>.ta.la.va.</em>). Each language has restrictions on what types of syllables are allowed, and sounds may need to be inserted or deleted to meet these restrictions. For example, if a language requires all syllables to end with a vowel, the input <em>kep</em> might map to <em>.ke.pa.</em>  (if the language uses insertion) or <em>.ke.</em>  (if the language uses deletion).</p>


	<p>The demo below shows how a neural network initialized with meta-learning can learn syllable structure mappings much more quickly than a neural network with a standard random initialization.</p>

<div style="margin: auto; max-width: 850px;" class="maindemowrapper">

<div style="overflow: hidden;">

	<div style="padding: 10px; overflow:hidden; float: left;">
		<span style="max-width: 410px;text-align: justify; margin-right: 10px; display: inline-block; font-size: 13px;"><b>Pattern to be learned:</b> 
			<span id="langdesc" style="text-align: justify">Delete sounds as necessary to ensure that the output is pronounceable, but otherwise change nothing; add periods to mark syllable boundariesDelete sounds as necessary to ensure that the output is pronounceable, but otherwise change nothing; add periods to mark syllable boundaries.</span>
		</span> 
		<button type="button" class="genbtn" onclick="random_language();" style="display: inline-block; vertical-align:top;">Random new language</button>
		<button type="button" class="genbtn" onclick="toggleshowadv()" style="display: inline-block; vertical-align:top;"><span id="advbtntxt">Show advanced settings</span></button> 
	</div>

	<div id="advancedsettings">
	<div>Language description: <span id="langdescold"></span></div>
	<div>Constraint ranking:</div>


	<div class="dropdown">
  		<button onclick="dropFunction()" class="dropbtn" id="rankbtn" style='font-variant:small-caps;'>Dropdown</button>
  		<div id="myDropdown" class="dropdown-content">
    		<a onclick="ranktoggle('(0, 1, 2, 3)')"><span style='font-variant:small-caps;'>Onset, NoCoda, Max &#187; Dep</span></a>
  			<a onclick="ranktoggle('(0, 1, 3, 2)')"><span style='font-variant:small-caps;'>Onset, NoCoda, Dep &#187; Max</span></a>
			<a onclick="ranktoggle('(0, 3, 2, 1)')"><span style='font-variant:small-caps;'>Onset, Dep &#187; Max &#187; NoCoda</span></a>
			<a onclick="ranktoggle('(1, 3, 2, 0)')"><span style='font-variant:small-caps;'>NoCoda, Dep &#187;  Max &#187; Onset</span></a>
			<a onclick="ranktoggle('(0, 2, 3, 1)')"><span style='font-variant:small-caps;'>Onset, Max &#187; Dep &#187; NoCoda</span></a>
			<a onclick="ranktoggle('(1, 2, 3, 0)')"><span style='font-variant:small-caps;'>NoCoda, Max &#187; Dep &#187; Onset</span></a>
			<a onclick="ranktoggle('(3, 2, 0, 1)')"><span style='font-variant:small-caps;'>Dep &#187; Max &#187; Onset, NoCoda</span></a>
			<a onclick="ranktoggle('(2, 3, 0, 1)')"><span style='font-variant:small-caps;'>Max &#187; Dep &#187; Onset, NoCoda</span></a>
		</div>
	</div>

		<div>Set of consonants: <button id="btnb" class="vinvbtn" type="button" onclick="ctoggle('b')">b</button><button id="btnc" class="vinvbtn" type="button" onclick="ctoggle('c')">c</button><button id="btnd" class="vinvbtn" type="button" onclick="ctoggle('d')">d</button><button id="btnf" class="vinvbtn" type="button" onclick="ctoggle('f')">f</button><button id="btng" class="vinvbtn" type="button" onclick="ctoggle('g')">g</button><button id="btnh" class="vinvbtn" type="button" onclick="ctoggle('h')">h</button><button id="btnj" class="vinvbtn" type="button" onclick="ctoggle('j')">j</button><button id="btnk" class="vinvbtn" type="button" onclick="ctoggle('k')">k</button><button id="btnl" class="vinvbtn" type="button" onclick="ctoggle('l')">l</button><button id="btnm" class="vinvbtn" type="button" onclick="ctoggle('m')">m</button><button id="btnn" class="vinvbtn" type="button" onclick="ctoggle('n')">n</button><button id="btnp" class="vinvbtn" type="button" onclick="ctoggle('p')">p</button><button id="btnq" class="vinvbtn" type="button" onclick="ctoggle('q')">q</button><button id="btnr" class="vinvbtn" type="button" onclick="ctoggle('r')">r</button><button id="btns" class="vinvbtn" type="button" onclick="ctoggle('s')">s</button><button id="btnt" class="vinvbtn" type="button" onclick="ctoggle('t')">t</button><button id="btnv" class="vinvbtn" type="button" onclick="ctoggle('v')">v</button><button id="btnw" class="vinvbtn" type="button" onclick="ctoggle('w')">w</button><button id="btnx" class="vinvbtn" type="button" onclick="ctoggle('x')">x</button><button id="btnz" class="vinvbtn" type="button" onclick="ctoggle('z')">z</button></div>
		<div>Set of vowels: <button id="btna" class="vinvbtn" type="button" onclick="vtoggle('a')">a</button><button id="btne" class="vinvbtn" type="button" onclick="vtoggle('e')">e</button><button id="btni" class="vinvbtn" type="button" onclick="vtoggle('i')">i</button><button id="btno" class="vinvbtn" type="button" onclick="vtoggle('o')">o</button><button id="btnu" class="vinvbtn" type="button" onclick="vtoggle('u')">u</button><button id="btnbiga" class="vinvbtn" type="button" onclick="vtoggle('A')">A</button><button id="btnbige" class="vinvbtn" type="button" onclick="vtoggle('E')">E</button><button id="btnbigi" class="vinvbtn" type="button" onclick="vtoggle('I')">I</button><button id="btnbigo" class="vinvbtn" type="button" onclick="vtoggle('O')">O</button><button id="btnbigu" class="vinvbtn" type="button" onclick="vtoggle('U')">U</button></div>
		<div>Consonant for insertion: <button id="btnepb" class="vinvbtn" type="button" onclick="ceptoggle('b')">b</button><button id="btnepc" class="vinvbtn" type="button" onclick="ceptoggle('c')">c</button><button id="btnepd" class="vinvbtn" type="button" onclick="ceptoggle('d')">d</button><button id="btnepf" class="vinvbtn" type="button" onclick="ceptoggle('f')">f</button><button id="btnepg" class="vinvbtn" type="button" onclick="ceptoggle('g')">g</button><button id="btneph" class="vinvbtn" type="button" onclick="ceptoggle('h')">h</button><button id="btnepj" class="vinvbtn" type="button" onclick="ceptoggle('j')">j</button><button id="btnepk" class="vinvbtn" type="button" onclick="ceptoggle('k')">k</button><button id="btnepl" class="vinvbtn" type="button" onclick="ceptoggle('l')">l</button><button id="btnepm" class="vinvbtn" type="button" onclick="ceptoggle('m')">m</button><button id="btnepn" class="vinvbtn" type="button" onclick="ceptoggle('n')">n</button><button id="btnepp" class="vinvbtn" type="button" onclick="ceptoggle('p')">p</button><button id="btnepq" class="vinvbtn" type="button" onclick="ceptoggle('q')">q</button><button id="btnepr" class="vinvbtn" type="button" onclick="ceptoggle('r')">r</button><button id="btneps" class="vinvbtn" type="button" onclick="ceptoggle('s')">s</button><button id="btnept" class="vinvbtn" type="button" onclick="ceptoggle('t')">t</button><button id="btnepv" class="vinvbtn" type="button" onclick="ceptoggle('v')">v</button><button id="btnepw" class="vinvbtn" type="button" onclick="ceptoggle('w')">w</button><button id="btnepx" class="vinvbtn" type="button" onclick="ceptoggle('x')">x</button><button id="btnepz" class="vinvbtn" type="button" onclick="ceptoggle('z')">z</button></div>
		<div>Vowel for insertion: <button id="btnepa" class="vinvbtn" type="button" onclick="veptoggle('a')">a</button><button id="btnepe" class="vinvbtn" type="button" onclick="veptoggle('e')">e</button><button id="btnepi" class="vinvbtn" type="button" onclick="veptoggle('i')">i</button><button id="btnepo" class="vinvbtn" type="button" onclick="veptoggle('o')">o</button><button id="btnepu" class="vinvbtn" type="button" onclick="veptoggle('u')">u</button><button id="btnepbiga" class="vinvbtn" type="button" onclick="veptoggle('A')">A</button><button id="btnepbige" class="vinvbtn" type="button" onclick="veptoggle('E')">E</button><button id="btnepbigi" class="vinvbtn" type="button" onclick="veptoggle('I')">I</button><button id="btnepbigo" class="vinvbtn" type="button" onclick="veptoggle('O')">O</button><button id="btnepbigu" class="vinvbtn" type="button" onclick="veptoggle('U')">U</button></div>

		<div>
			<button type="button" onclick="renew_language()">Renew</button>
		</div>

	</div>


	<div style="float: left; padding: 10px;">
		<div "text-align: center; padding: 10px;">
			<div style="width: 100%; margin: 0 auto; padding: 10px;">
				<b>Training examples:</b> <span id="traincount">0</span>
			</div> 
		</div>
		<div id="trainingexamplelist" style="border: solid; height:150px; width: 200px; overflow: scroll; padding: 10px;"></div>
		<br>
		<div style="text-align: center;">
			<button type="button" class="trainbtn" onclick="update_display(seq2seq, 'meta');update_display(seq2seqb, 'random');fitfitfit(seq2seq, 'meta');fitfitfit(seq2seqb, 'random', add_train=true)" style="font-size: 16px; display: inline-block;" id="oneexamplebtn">Train on one example</button>
		</div>
	</div>


	<div style="float: left; padding: 10px;">

		<div style="text-align: center; padding: 10px;"><b>Test set predictions</b></div>
		<div>
			<table class="hor-minimalist-a">
				<tr class="top">
					<th style="width:50;" class='cell'><div>Input</div></th>
					<th style="width:100;" class='cell'><div>Correct output</div></th>
					<th style="width:110;" class='cell'><div>Meta-initialized<br>model's output</div></th>
					<th style="width:150;" class='cellcollapsible'><div class='cell'>Randomly-initialized<br>model's output</div></th>
				</tr>
				<tr>
					<td class='cell'><div id="inb1">rOau</div></td>
					<td class='cell'><div id="corrb1">.rO.a.u.</div></td>
					<td class='cell'><div id="metaoutb1">.rO.a.u.</div></td>
					<td class='cellcollapsible'><div id="randomoutb1">.rO.a.u.</div></td>
				</tr>
				<tr>
					<td class='cell'><div id="inb2">axxaO</div></td>
					<td class='cell'><div id="corrb2">.a.xa.O.</div></td>
					<td class='cell'><div id="metaoutb2">.a.xa.O.</div></td>
					<td class='cellcollapsible'><div id="randomoutb2">.a.xa.O.</div></td>
				</tr>
				<tr>
					<td class='cell'><div id="inb3">rxxa</div></td>
					<td class='cell'><div id="corrb3">.xa.</div></td>
					<td class='cell'><div id="metaoutb3">.xa.</div></td>
					<td class='cellcollapsible'><div id="randomoutb3">.xa.</div></td>
				</tr>
				<tr>
					<td class='cell'><div id="inb4">axrxu</div></td>
					<td class='cell'><div id="corrb4">.a.xu.</div></td>
					<td class='cell'><div id="metaoutb4">.a.xu.</div></td>
					<td class='cellcollapsible'><div id="randomoutb4">.a.xu.</div></td>
				</tr>
				<tr>
					<td class='cell'><div id="inb5">ttxaO</div></td>
					<td class='cell'><div id="corrb5">.xa.O.</div></td>
					<td class='cell'><div id="metaoutb5">.xa.O.</div></td>
					<td class='cellcollapsible'><div id="randomoutb5">.xa.O.</div></td>
				</tr>
				<tr>
					<td class='cell'><div id="inb6">rOau</div></td>
					<td class='cell'><div id="corrb6">.rO.a.u.</div></td>
					<td class='cell'><div id="metaoutb6">.rO.a.u.</div></td>
					<td class='cellcollapsible'><div id="randomoutb6">.rO.a.u.</div></td>
				</tr>
			</table>
		</div>

	</div>

	</div>
</div>

<div style="padding-top: 15px; padding-bottom: 40px; padding-left: 50px; padding-right: 50px; font-size: 13px;">
	<em>How to use: Click "Train on one example" to show the models a single input-output pair. Click "Random new language" or "Manually define language" to restart the demo with a new language.</em>
</div>


<p>The meta-initialized model can typically learn any of these syllable structure mappings from fewer than 100 examples&mdash;sometimes substantially fewer. In contrast, after the same number of examples, the outputs of the randomly initialized model are usually nowhere near the correct answers.</p>

<h2>Generalization</h2>

<p>The main goal of our framework is to give a model a certain set of inductive biases. While rapid learning is one piece of evidence that a model has acquired some useful inductive biases, a more direct way to study a learner's inductive biases is through generalization: how does the learner handle novel types of examples?</p>

1,3,2,0
<table>
	<tr>
		<th>input</th>
		<th>correct output</th>
		<th>0 iterations</th>
		<th>1000 iterations</th>
		<th>2000 iterations</th>
		<th>3000 iterations</th>
		<th>4000 iterations</th>
		<th>5000 iterations</th>
		<th>6000 iterations</th>
		<th>7000 iterations</th>
		<th>8000 iterations</th>
		<th>9000 iterations</th>
		<th>10000 iterations</th>
	</tr>
	<tr>
		<td>uttxr</td>
		<td>.u.</td>
		<td>pzllllllllllllllllll</td>
		<td>.u.xu.</td>
		<td>.u.</td>
		<td>.u.</td>
		<td>.u.</td>
		<td>.u.</td>
		<td>.u.</td>
		<td>.u.</td>
		<td>.u.</td>
		<td>.u.</td>
		<td>.u.</td>
	</tr>
	<tr>
		<td>raxur</td>
		<td>.ra.xu.</td>
		<td>pzllllllllllllllllll</td>
		<td>.ra.xu.</td>
		<td>.ra.xu.</td>
		<td>.ra.xu.</td>
		<td>.ra.xu.u.</td>
		<td>.ra.</td>
		<td>.ra.xu.</td>
		<td>.ra.xu.</td>
		<td>.ra.xu.</td>
		<td>.ra.xu.</td>
		<td>.ra.xu.</td>
	</tr>
	<tr>
		<td>Oar</td>
		<td>.O.a.</td>
		<td>pzllllllllllllllllll</td>
		<td>.O.ra.</td>
		<td>.O.a.</td>
		<td>.O.a.</td>
		<td>.O.a.</td>
		<td>.O.a.</td>
		<td>.O.a.</td>
		<td>.O.a.</td>
		<td>.O.a.</td>
		<td>.O.a.</td>
		<td>.O.a.</td>
	</tr>
	<tr>
		<td>atrau</td>
		<td>.a.ra.u.</td>
		<td>pzllllllllllllllllll</td>
		<td>.a.ra.</td>
		<td>.a.ra.u.</td>
		<td>.a.ru.u.</td>
		<td>.a.ra.u.</td>
		<td>.a.ra.</td>
		<td>.a.ra.u.</td>
		<td>.a.ra.u.</td>
		<td>.a.ra.u.</td>
		<td>.a.ra.u.</td>
		<td>.a.ra.u.</td>
	</tr>
	<tr>
		<td>tOuxa</td>
		<td>.tO.u.xa.</td>
		<td>pzllllllllllllllllll</td>
		<td>.tO.xo.x.</td>
		<td>.tO.u.xa.</td>
		<td>.tO.u.xa.</td>
		<td>.tO.u.xa.</td>
		<td>.tO.u.xa.</td>
		<td>.tO.u.xa.</td> 
		<td>.tO.u.xa.</td>
		<td>.tO.u.xa.</td>
		<td>.tO.u.xa.</td>
		<td>.tO.u.xa.</td>
	</tr>
	<tr>
		<td>xruto</td>
		<td>.ru.tO.</td>
		<td>plllllllllllllllllll</td>
		<td>.tu.xO.</td>
		<td>.tu.</td>
		<td>.ru.tO.</td>
		<td>.ru.tO.O.</td>
		<td>.ru.tO.</td>
		<td>.ru.tO.</td>
		<td>.ru.tO.</td>
		<td>.ru.tO.</td>
		<td>.ru.tO.</td>
		<td>.ru.tO.</td>
	</tr>
	<tr>
		<td>xOxra</td>
		<td>.xO.ra.</td>
		<td>pzllllllllllllllllll</td>
		<td>.xO.xa.</td>
		<td>.xO.xa.</td>
		<td>.xO.ra.</td>
		<td>.xO.ra.</td>
		<td>.xO.ra.</td>
		<td>.xO.ra.</td>
		<td>.xO.ra.</td>
		<td>.xO.ra.</td>
		<td>.xO.ra.</td>
		<td>.xO.ra.</td>
	</tr>
	<tr>
		<td>uuuuO</td>
		<td>.u.u.u.u.O.</td>
		<td>xhIjjjjjjjjjjjjjjjjj</td>
		<td>.u.uu.O..</td>
		<td>.u.u.u.u.</td>
		<td>.u.u.u.u.O.</td>
		<td>.u.u.u.O.O.</td>
		<td>.u.u.u.O.</td>
		<td>.u.u.u.u.</td>
		<td>.u.u.u.u.O.</td>
		<td>.u.u.u.u.O.</td>
		<td>.u.u.u.u.u.</td>
		<td>.u.u.u.u.O.</td>
	</tr>
	<tr>
		<td>xt</td>
		<td></td>
		<td>plllllllllllllllllll</td>
		<td></td>
		<td></td>
		<td></td>
		<td></td>
		<td></td>
		<td></td>
		<td></td>
		<td></td>
		<td></td>
		<td></td>
	</tr>
	<tr>
		<td>aata</td>
		<td>.a.a.ta.</td>
		<td>paw.www.www.www.wwww</td>
		<td>.a.ta.</td>
		<td>.a.a.ta.</td>
		<td>.a.a.ta.</td>
		<td>.a.a.ta.</td>
		<td>.a.a.ta.</td>
		<td>.a.a.ta.</td>
		<td>.a.a.ta.</td>
		<td>.a.a.ta.</td>
		<td>.a.a.ta.</td>
		<td>.a.a.ta.</td>
	</tr>
</table>

2,3,1,0
<table>
	<tr>
		<th>input</th>
		<th>correct output</th>
		<th>0 iterations</th>
		<th>1000 iterations</th>
		<th>2000 iterations</th>
		<th>3000 iterations</th>
		<th>4000 iterations</th>
		<th>5000 iterations</th>
		<th>6000 iterations</th>
		<th>7000 iterations</th>
		<th>8000 iterations</th>
		<th>9000 iterations</th>
		<th>10000 iterations</th>
	</tr>
	<tr>
		<td>IIEm</td>
		<td>.I.I.Em.</td>
		<td>emmm....Okkkkkkkkkkk</td>
		<td>.I.mI.E..</td>
		<td>.I.E.m</td>
		<td>.I.I.Em.</td>
		<td>.I.I.Em.</td>
		<td>.I.I.Em.</td>
		<td>.I.I.Em.</td>
		<td>.I.I.E.Em.</td>
		<td>.I.I.Em.</td>
		<td>.I.I.Em.</td>
		<td>.I.I.Em.</td>
	</tr>
	<tr>
		<td>pppE</td>
		<td>.pEp.pE.</td>
		<td>emmm....Okkkkkkkkkkk</td>
		<td>.pE.pE.EE..</td>
		<td>.pEp.pE..</td>
		<td>.pEp.pE.</td>
		<td>.pE..pE.</td>
		<td>.pEp.pE.</td>
		<td>.pEp.pE.</td>
		<td>.pEp.pE.</td>
		<td>.pEp.pE.</td>
		<td>.pEp.pE.</td>
		<td>.pEp.pE.</td>
	</tr>
	<tr>
		<td>ImE</td>
		<td>.I.mE.</td>
		<td>emmm....Okkkkkkkkkkk</td>
		<td>.I.mE..</td>
		<td>.I.mE.</td>
		<td>.I.mE.</td>
		<td>.I.mE.</td>
		<td>.I.mE.</td>
		<td>.I.mE.</td>
		<td>.I.mE.</td>
		<td>.I.mE.</td>
		<td>.I.mE.</td>
		<td>.I.mE.</td>
	</tr>
	<tr>
		<td></td>
		<td></td>
		<td>emmm....Okkkkkkkkkkk</td>
		<td>.EE.</td>
		<td>.EE.</td>
		<td>.EE.</td>
		<td>.EE.</td>
		<td>.xE.</td>
		<td>.cE.</td>
		<td>.xE.</td>
		<td>.xE.</td>
		<td>.xE.</td>
		<td>.cE.</td>
	</tr>
	<tr>
		<td>xEpcI</td>
		<td>.xEp.cI.</td>
		<td>eNmmm....Okkkkkkkkkk</td>
		<td>.xE.......</td>
		<td>.xE..pE..I.</td>
		<td>.xE..pI.</td>
		<td>.xE..cc.II.</td>
		<td>.xEp.cI.</td>
		<td>.xEp.cI.</td>
		<td>.xEp.cI.</td>
		<td>.xEp.cI.</td>
		<td>.xEp.cI.</td>
		<td>.xEp.cI.</td>
	</tr>
	<tr>
		<td>mExE</td>
		<td>.mE.xE.</td>
		<td>emmm....Okkkkkkkkkkk</td>
		<td>.mE.EE.E.</td>
		<td>.mExxE..</td>
		<td>.mE.xE.</td>
		<td>.mE.xE.</td>
		<td>.mE.xE.</td>
		<td>.mE.xE.</td>
		<td>.mE.xE.</td>
		<td>.mE.xE.</td>
		<td>.mE.xE.</td>
		<td>.mE.xE.</td>
	</tr>
	<tr>
		<td>IIIEE</td>
		<td>.I.I.I.E.E.</td>
		<td>emmm....Okkkkkkkkkkk</td>
		<td>.I.II.E.E..</td>
		<td>.I.I.EE.</td>
		<td>.I.I.I.E.</td>
		<td>.I.I.I.E.E.</td>
		<td>.I.I.I.E.E.</td>
		<td>.I.I.I.E.E.</td>
		<td>.I.I.I.E.E.</td>
		<td>.I.I.I.E.E.</td>
		<td>.I.I.I.E.E.</td>
		<td>.I.I.I.E.E.</td>
	</tr>
	<tr>
		<td>Exppp</td>
		<td>.E.xEp.pEp.</td>
		<td>eNmmm....Okkkkkkkkkk</td>
		<td>.E.xEppEpp.</td>
		<td>.Ex.pEppEp.</td>
		<td>.E.xEp.pEp.</td>
		<td>.E.xEp.pEp.</td>
		<td>.E.xEp.pEp.</td>
		<td>.E.xEp.pEp.</td>
		<td>.E.xEp.pEp.</td>
		<td>.E.xEp.pEp.</td>
		<td>.E.xEp.pEp.</td>
		<td>.E.xEp.pEp.</td> 
	</tr>
	<tr>
		<td>IpEIc</td>
		<td>.I.pE.Ic.</td>
		<td>emmm....Okkkkkkkkkk</td>
		<td>.I..pE.E...</td>
		<td>.I.pE.I..</td>
		<td>.I.pE.cc.</td>
		<td>.I.pE.Ic.</td>
		<td>.I.pE.Ic.</td>
		<td>.I.pE.Ic.</td>
		<td>.I.pE.Ic.</td>
		<td>.I.pE.Ic.</td>
		<td>.I.pE.Ic.</td>
		<td>.I.pE.Ic.</td>
	</tr>
	<tr>
		<td>EIIpm</td>
		<td>.E.I.I.pEm.</td>
		<td>emmm....Okkkkkkkkkkk</td>
		<td>.I.E..E..E.</td>
		<td>.E.I.pEp.</td>
		<td>.E.I.I.pEm.</td>
		<td>.E.I.I.pEm.</td>
		<td>.E.I.I.pEm.</td>
		<td>.E.I.I.pEm.</td>
		<td>.E.I.I.pEm.</td>
		<td>.E.I.I.pEm.</td>
		<td>.E.I.I.pEm.</td>
		<td>.E.I.I.pEm.</td>
	</tr>
</table>


0,2,3,1

<table>
	<tr>
		<th>input</th>
		<th>correct output</th>
		<th>0 iterations</th>
		<th>1000 iterations</th>
		<th>2000 iterations</th>
		<th>3000 iterations</th>
		<th>4000 iterations</th>
		<th>5000 iterations</th>
		<th>6000 iterations</th>
		<th>7000 iterations</th>
		<th>8000 iterations</th>
		<th>9000 iterations</th>
		<th>10000 iterations</th>
	</tr>
	<tr>
		<td>Uktt</td>
		<td>.kUk.tIt.</td>
		<td>I.kI.kkI..kkI..kI.kk</td>
		<td>.kU.tIt.</td>
		<td>.kUk.IIt.</td>
		<td>.kUk.tIt.</td>
		<td>.kUk.tIt.</td>
		<td>.kUk.tIt.</td>
		<td>.kUk.tIt.</td>
		<td>.kUk.tIt.</td>
		<td>.kUk.tIt.</td>
		<td>.kUk.tIt.</td>
		<td>.kUk.tIt.</td>
	</tr>
	<tr>
		<td>aukk</td>
		<td>.ka.ku.kIk.</td>
		<td>II.kkI..kkI..kI.kkI.</td>
		<td>.ka.kukk</td>
		<td>.ka.ku.kIk.</td>
		<td>.ka.ku.kIk.</td>
		<td>.ka.ku.kIk.</td>
		<td>.ka.ku.kIk.</td>
		<td>.ka.ku.kIk.</td>
		<td>.ka.ku.kIk.</td>
		<td>.ka.ku.kIk.</td>
		<td>.ka.ku.kIk.</td>
		<td>.ka.ku.kIk.</td>
	</tr>
	<tr>
		<td>Ita</td>
		<td>.kI.ta.</td>
		<td>II.kkI..kkI..kI.kkI.</td>
		<td>.kI.ka..</td>
		<td>.kI.ta.</td>
		<td>.kI.ta.</td>
		<td>.kI.ta.</td>
		<td>.kI.ta.</td>
		<td>.kI.ta.</td>
		<td>.kI.ta.</td>
		<td>.kI.ta.</td>
		<td>.kI.ta.</td>
		<td>.kI.ta.</td>
	</tr>
	<tr>
		<td>tak</td>
		<td>.tak.</td>
		<td>II.kkI..kkI..kI.kkI.</td>
		<td>.tI..</td>
		<td>.ta.k</td>
		<td>.tak.</td>
		<td>.tak.</td>
		<td>.tak.</td>
		<td>.tak.</td> 
		<td>.tak.</td>
		<td>.tak.</td>
		<td>.tak.</td>
		<td>.ta.kak.</td>
	</tr>
	<tr>
		<td>ttktU</td>
		<td>.tI.tIk.tU.</td>
		<td>nkaaaaaaaaaaaaaaaaaa</td>
		<td>.tI.tIt.</td>
		<td>.tI..It.kU.</td>
		<td>.tI.tIt.tU.</td>
		<td>.tI.tIk.tU.</td>
		<td>.tI.tIk.tU.</td>
		<td>.tI.tIk.tU.</td> 
		<td>.tI.tIk.tU.</td>
		<td>.tI.tIk.tU.</td>
		<td>.tI.tIk.tU.</td>
		<td>.tI.tIk.tU.</td>
	</tr>
	<tr>
		<td>ItUIa</td>
		<td>.kI.tU.kI.ka.</td>
		<td>II.kkI..kkI..kI.kkI.</td>
		<td>.kI.kI.ka.ka.</td>
		<td>.kI.tU.kU.ka.</td>
		<td>.kI.tU.kI.ka.</td>
		<td>.kI.tU.kI.ka.</td>
		<td>.kI.tU.kI.ka.</td>
		<td>.kI.tU.kI.ka.</td>
		<td>.kI.tU.kI.ka.</td>
		<td>.kI.tU.kI.ka.</td>
		<td>.kI.tU.kI.ka.</td>
		<td>.kI.tU.kI.ka.</td>
	</tr>
	<tr>
		<td>kuIta</td>
		<td>.ku.kI.ta.</td>
		<td>I.kI.kkI..kkI..kI.kk</td>
		<td>.kU.kI.ka..</td>
		<td>.ku.kI.tI.</td>
		<td>.ku.kI.ta.</td>
		<td>.ku.kI.ta.</td>
		<td>.ku.kI.ta.</td>
		<td>.ku.kI.ta.</td>
		<td>.ku.kI.ta.</td>
		<td>.ku.kI.ta.</td>
		<td>.ku.kI.ta.</td>
		<td>.ku.kI.ta.</td>
	</tr>
	<tr>
		<td>katta</td>
		<td>.kat.ta.</td>
		<td>I.kI.kkI..kkI..kI.kk</td>
		<td>.ka.tat..</td>
		<td>.kat.ta.</td>
		<td>.kat.ta.</td>
		<td>.kat.ta.</td>
		<td>.kat.ta.</td>
		<td>.kat.ta.</td>
		<td>.kat.ta.</td>
		<td>.kat.ta.</td>
		<td>.kat.ta.</td>
		<td>.kat.ta.</td>
	</tr>
	<tr>
		<td>I</td>
		<td>.kI.</td>
		<td>IIkkkaaaaaaaaaaaaaaa</td>
		<td>.kI.</td>
		<td>.kI.</td>
		<td>.kI.</td>
		<td>.kI.</td>
		<td>.kI.</td>
		<td>.kI.</td>
		<td>.kI.</td>
		<td>.kI.</td>
		<td>.kI.</td>
		<td></td>
	</tr>
	<tr>
		<td>kattu</td>
		<td>.kat.tu.</td>
		<td>I.kkI..kkI..kI.kkI..</td>
		<td>.ka.tut</td>
		<td>.kat.ku.</td>
		<td>.kat.tu.</td>
		<td>.kat.tu.</td>
		<td>.kat.tu.</td>
		<td>.kat.tu.</td>
		<td>.kat.tu.</td>
		<td>.kat.tu.</td>
		<td>.kat.tu.</td>
		<td>.kat.tu.</td>
	</tr>
</table>

0,1,2,3
<table>
	<tr>
		<th>input</th>
		<th>correct output</th>
		<th>0 iterations</th>
		<th>1000 iterations</th>
		<th>2000 iterations</th>
		<th>3000 iterations</th>
		<th>4000 iterations</th>
		<th>5000 iterations</th>
		<th>6000 iterations</th>
		<th>7000 iterations</th>
		<th>8000 iterations</th>
		<th>9000 iterations</th>
		<th>10000 iterations</th>
	</tr>
	<tr>
		<td>btubo</td>
		<td>.bU.tu.bo.</td>
		<td>uttjutjutjutjutjutju</td>
		<td>.bU.bo.fo.</td>
		<td>.bU.tu.bo.</td>
		<td>.bU.tu.bo.</td>
		<td>.bU.tu.bo.</td>
		<td>.bU.tu.bo.</td>
		<td>.bU.tu.bo.</td>
		<td>.bU.tu.bo.</td>
		<td>.bU.tu.bo.</td>
		<td>.bU.tu.bo.</td>
		<td>.bU.tu.bo.</td>
	</tr>
	<tr>
		<td>uuutb</td>
		<td>.fu.fu.fu.tU.bU.</td>
		<td>tNujutjutjutjutjutju</td>
		<td>.fu.fu.fu.bU.bU.</td>
		<td>.fu.fu.tU.bU.bU.</td>
		<td>.fu.fu.tU.bU.bU.</td>
		<td>.fu.fu.fu.tU.</td>
		<td>.fu.fu.fu.tU.bU.</td>
		<td>.fu.fu.tU.bU.bU.</td>
		<td>.fu.fu.tU.bU.bU.</td>
		<td>.fu.fu.fu.tU.bU.</td>
		<td>.fu.fu.fu.tU.bU.</td>
		<td>.fu.fu.fu.tU.bU.</td>
	</tr>
	<tr>
		<td>fffbf</td>
		<td>.fU.fU.fU.bU.fU.</td>
		<td>jutjutjutjutjutjutju</td>
		<td>.fU.fU.bU.bU.</td>
		<td>.fU.fU.bU.fU.</td>
		<td>.fU.fU.fU.bU.fU.</td>
		<td>.fU.fU.fU.fU.fU.</td>
		<td>.fU.fU.bU.fU.fU.</td>
		<td>.fU.fU.bU.bU.fU.</td>
		<td>.fU.fU.fU.bU.fU.</td>
		<td>.fU.fU.fU.bU.fU.</td>
		<td>.fU.fU.fU.bU.fU.</td>
		<td>.fU.fU.fU.bU.fU.</td>
	</tr>
	<tr>
		<td>votuv</td>
		<td>.vo.tu.vU.</td>
		<td>uttjutjutjutjutjutju</td>
		<td>.vo.vo.vU.vU.</td>
		<td>.vo.tu.vU.</td>
		<td>.vo.tu.vU.</td>
		<td>.vo.tu.vU.</td>
		<td>.vo.tu.vU.</td>
		<td>.vo.tu.vU.</td>
		<td>.vo.tu.vU.</td> 
		<td>.vo.tu.vU.</td>
		<td>.vo.tu.vU.</td>
		<td>.vo.tu.vU.</td>
	</tr>
	<tr>
		<td>uoUUf</td>
		<td>.fu.fo.fU.fU.fU.</td>
		<td>jutjutjutjutjutjutju</td>
		<td>.fu.fo.fU.fU.fU.</td>
		<td>.fu.fo.fU.fU.</td>
		<td>.fu.fo.fU.fU.fU.</td>
		<td>.fu.fo.fU.fU.fU.</td>
		<td>.fu.fo.fU.fU.fU.</td>
		<td>.fu.fo.fU.fU.fU.</td>
		<td>.fu.fo.fU.fU.fU.</td>
		<td>.fu.fo.fU.fU.fU.</td>
		<td>.fu.fo.fU.fU.fU.</td>
		<td>.fu.fo.fU.fU.fU.</td>
	</tr>
	<tr>
		<td>vuufu</td>
		<td>.vu.fu.fu.</td>
		<td>tNujutjutjutjutjutju</td>
		<td>.vu.fu.fu.</td>
		<td>.vu.fu.fu.</td>
		<td>.vu.fu.fu.</td>
		<td>.vu.fu.fu.</td>
		<td>.vu.fu.fu.</td>
		<td>.vu.fu.fu.</td>
		<td>.vu.fu.fu.</td> 
		<td>.vu.fu.fu.</td>
		<td>.vu.fu.fu.</td>
		<td>.vu.fu.fu.</td>
	</tr>
	<tr>
		<td>ubuu</td>
		<td>.fu.bu.fu.</td>
		<td>rZAbwjutjutjutjutjut</td>
		<td>.fu.bu.fu.</td>
		<td>.fu.bu.fu.</td>
		<td>.fu.bu.fu.</td>
		<td>.fu.bu.fu.</td>
		<td>.fu.bu.fu.</td>
		<td>.fu.bu.fu.</td>
		<td>.fu.bu.fu.</td>
		<td>.fu.bu.fu.</td>
		<td>.fu.bu.fu.</td>
		<td>.fu.bu.fu.</td>
	</tr>
	<tr>
		<td>fvuof</td>
		<td>.fU.vu.fo.fU.</td>
		<td>jutjutjutjutjutjutju</td>
		<td>.fU.fo.fU.fU.</td>
		<td>.fU.vu.fo.fU.</td>
		<td>.fU.vu.fo.fU.</td>
		<td>.fU.vu.fo.fU.</td>
		<td>.fU.vu.fo.fU.</td>
		<td>.fU.vu.fo.fU.</td>
		<td>.fU.vu.fo.fU.</td>
		<td>.fU.vu.fo.fU.</td>
		<td>.fU.vu.fo.fU.</td>
		<td>.fU.vu.fo.fU.</td>
	</tr>
	<tr>
		<td>vuofu</td>
		<td>.vu.fo.fu.</td>
		<td>tNujutjutjutjutjutju</td>
		<td>.vu.fo.fu.fU.</td>
		<td>.vu.fo.fu.</td>
		<td>.vu.fo.fu.</td>
		<td>.vu.fo.fu.</td>
		<td>.vu.fo.fu.</td>
		<td>.vu.fo.fu.</td>
		<td>.vu.fo.fu.</td>
		<td>.vu.fo.fu.</td>
		<td>.vu.fo.fu.</td>
		<td>.vu.fo.fu.</td>
	</tr>
	<tr>
		<td>ootUU</td>
		<td>.fo.fo.tU.fU.</td>
		<td>ffffffffffffffffffff</td>
		<td>.fo.fo.fU.tU.tU.</td>
		<td>.fo.fo.tU.fU.</td>
		<td>.fo.fo.tU.fU.</td>
		<td>.fo.fo.tU.fU.</td>
		<td>.fo.fo.tU.fU.</td>
		<td>.fo.to.tU.fU.</td>
		<td>.fo.to.tU.fU.</td> 
		<td>.fo.to.tU.fU.</td>
		<td>.fo.to.tU.fU.</td>
		<td>.fo.to.tU.fU.</td>
	</tr>
</table>


3,2,1,0
<table>
	<tr>
		<th>input</th>
		<th>correct output</th>
		<th>0 iterations</th>
		<th>1000 iterations</th>
		<th>2000 iterations</th>
		<th>3000 iterations</th>
		<th>4000 iterations</th>
		<th>5000 iterations</th>
		<th>6000 iterations</th>
		<th>7000 iterations</th>
		<th>8000 iterations</th>
		<th>9000 iterations</th>
		<th>10000 iterations</th>
	</tr>
	<tr>
		<td>Ebhhh</td>
		<td>.Eh.</td>
		<td>iibEuccEccEccEccEccE</td>
		<td>.Eh.</td>
		<td>.Eh.hh.</td>
		<td>.Eh.</td>
		<td>.Eh.</td>
		<td>.Eh.</td> 
		<td>.Eh.</td>
		<td>.Eh.</td>
		<td>.Eh.</td>
		<td>.Eh.</td>
		<td>.Eh.</td>
	</tr>
	<tr>
		<td>AAr</td>
		<td>.A.Ar.</td>
		<td>nquccEccEccEccEccEcc</td>
		<td>.A.AA.</td>
		<td>.A.A.Ar.</td>
		<td>.A.Ar.</td>
		<td>.A.Ar.</td>
		<td>.A.Ar.</td>
		<td>.A.Ar.</td>
		<td>.A.Ar.</td>
		<td>.A.Ar.</td>
		<td>.A.Ar.</td>
		<td>.A.Ar.</td>
	</tr>
	<tr>
		<td>EhrA</td>
		<td>.Eh.rA.</td>
		<td>bEuccEccEccEccEccEcc</td>
		<td>.Er.AA.</td>
		<td>.Er.rA.</td>
		<td>.Eh.hA.</td>
		<td>.Er.rA.</td>
		<td>.Eh.rA.</td>
		<td>.Eh.rA.</td>
		<td>.Eh.rA.</td>
		<td>.Eh.rA.</td>
		<td>.Eh.rA.</td>
		<td>.Eh.rA.</td>
	</tr>
	<tr>
		<td>AhrhA</td>
		<td>.Ar.hA.</td>
		<td>xuccEccEccEccEccEccE</td>
		<td>.A.AA.</td>
		<td>.Ah.hA..A.</td>
		<td>.Ah.hA.</td>
		<td>.Ah.rA.</td>
		<td>.Ah.hA.</td>
		<td>.Ah.hA.</td>
		<td>.Ah.hA.</td>
		<td>.Ah.hA.</td>
		<td>.Ah.hA.</td>
		<td>.Ah.hA.</td>
	</tr>
	<tr>
		<td>AAhEE</td>
		<td>.A.A.hE.E.</td>
		<td>ujccEccEccEccEccEccE</td>
		<td>.A.A.EE.</td>
		<td>.A.A.rE.E.</td>
		<td>.A.A.hE.</td>
		<td>.A.A.hE.E.</td>
		<td>.A.A.hA.E.</td>
		<td>.A.A.hE.E.</td>
		<td>.A.A.hE.E.</td> 
		<td>.A.A.hE.E.</td> 
		<td>.A.A.hE.E.</td> 
		<td>.A.A.hE.E.</td> 
	</tr>
	<tr>
		<td>rhA</td>
		<td>.hA.</td>
		<td>xuccEccEccEccEccEccE</td>
		<td>.hA.</td>
		<td>.hA.</td>
		<td>.hA.</td>
		<td>.hA.</td>
		<td>.hA.</td>
		<td>.hA.</td>
		<td>.hA.</td>
		<td>.hA.</td>
		<td>.hA.</td>
		<td>.hA.</td>
	</tr>
	<tr>
		<td>EArrA</td>
		<td>.E.Ar.rA.</td>
		<td>xuccEccEccEccEccEccE</td>
		<td>.E.AA.AA.</td>
		<td>.E.Ar.rA.</td>
		<td>.E.Ar.rA.</td>
		<td>.E.Ar.rA.</td>
		<td>.E.Ar.rA.</td>
		<td>.E.Ar.rA.</td>
		<td>.E.Ar.rA.</td>
		<td>.E.Ar.rA.</td>
		<td>.E.Ar.rA.</td>
		<td>.E.Ar.rA.</td>
	</tr>
	<tr>
		<td>AEErE</td>
		<td>.A.E.E.rE.</td>
		<td>ibEuccEccEccEccEccEc</td>
		<td>.A.E.E..</td>
		<td>.A.E.rE.E.</td>
		<td>.A.E.EE.E.</td>
		<td>.A.E.E.rE.</td>
		<td>.A.E.E.rE.</td>
		<td>.A.E.E.rE.</td>
		<td>.A.E.E.rE.</td>
		<td>.A.E.E.rE.</td>
		<td>.A.E.E.rE.</td>
		<td>.A.E.E.rE.</td>
	</tr>
	<tr>
		<td>EEEE</td>
		<td>.E.E.E.E.</td>
		<td>ujccEccEccEccEccEccE</td>
		<td>.E.E.E.E.</td>
		<td>.E.E.E.E.</td>
		<td>.E.E.E.E..</td>
		<td>.E.E.E.E.</td>
		<td>.E.E.E.E.</td>
		<td>.E.E.E.E.</td>
		<td>.E.E.E.E.</td>
		<td>.E.E.E.E.</td>
		<td>.E.E.E.E.</td>
		<td>.E.E.E.E.</td>
	</tr>
	<tr>
		<td>hrAA</td>
		<td>.rA.A.</td>
		<td>xxuccEccEccEccEccEcc</td>
		<td>.rA.A.</td>
		<td>.rA.A.</td>
		<td>.rA.A.</td>
		<td>.rA.A.</td>
		<td>.rA.A.</td>
		<td>.rA.A.</td>
		<td>.rA.A.</td>
		<td>.rA.A.</td>
		<td>.rA.A.</td>
		<td>.rA.A.</td>
	</tr>
</table>

1,2,3,0
<table>
	<tr>
		<th>input</th>
		<th>correct output</th>
		<th>0 iterations</th>
		<th>1000 iterations</th>
		<th>2000 iterations</th>
		<th>3000 iterations</th>
		<th>4000 iterations</th>
		<th>5000 iterations</th>
		<th>6000 iterations</th>
		<th>7000 iterations</th>
		<th>8000 iterations</th>
		<th>9000 iterations</th>
		<th>10000 iterations</th>
	</tr>
	<tr>
		<td>rUUUr</td>
		<td>.rU.U.U.re.</td>
		<td>fddddddddddddddddddd</td>
		<td>.rU.U.re.</td>
		<td>.rU.U.U.re.</td>
		<td>.rU.U.U.re.</td>
		<td>.rU.U.U.re.</td>
		<td>.rU.U.U.U.e.</td>
		<td>.rU.U.U.re.</td>
		<td>.rU.U.U.re.</td>
		<td>.rU.U.U.re.</td>
		<td>.rU.U.U.re.</td>
		<td>.rU.U.U.re.</td>
	</tr>
	<tr>
		<td>UU</td>
		<td>.U.U.</td>
		<td>xcrfdddddddddddddddd</td>
		<td>.U.U.</td>
		<td>.U.U.</td>
		<td>.U.U.</td>
		<td>.U.</td>
		<td>.U.U.</td>
		<td>.U.</td>
		<td>.U.</td>
		<td>.U.</td>
		<td>.U.</td>
		<td>.U.</td>
	</tr>
	<tr>
		<td>heee</td>
		<td>.he.e.e.</td>
		<td>xbxbkxbkxbkkxbkxbkkx</td>
		<td>.he.e.e.</td>
		<td>.he.e.e.</td>
		<td>.he.e.e.</td>
		<td>.he.e.e.</td>
		<td>.he.e.e.e.</td>
		<td>.he.e.e.</td>
		<td>.he.e.e.</td>
		<td>.he.e.e.</td>
		<td>.he.e.e.</td>
		<td>.he.e.e.</td>
	</tr>
	<tr>
		<td>eger</td>
		<td>.e.ge.re.</td>
		<td>ehcrfddddddddddddddd</td>
		<td>.e.ge.re.</td>
		<td>.e.ge.re.</td>
		<td>.e.ge.re.</td>
		<td>.e.ge.re.</td>
		<td>.e.ge.re.</td>
		<td>.e.ge.re.</td>
		<td>.e.ge.re.</td> 
		<td>.e.ge.re.</td>
		<td>.e.ge.re.</td>
		<td>.e.ge.re.</td>
	</tr>
	<tr>
		<td>heeUU</td>
		<td>.he.e.U.U.</td>
		<td>xSOSxcrfdddddddddddddd</td>
		<td>.he.e.e...</td>
		<td>.he.e.U.U.</td>
		<td>.he.e.U.U.</td>
		<td>.he.e.U.U.</td>
		<td>.he.e.U.U.</td>
		<td>.he.e.U.U.</td>
		<td>.he.e.U.U.</td>
		<td>.he.e.U.U.</td>
		<td>.he.e.U.U.</td>
		<td>.he.e.U.U.</td>
	</tr>
	<tr>
		<td>heUh</td>
		<td>.he.U.he.</td>
		<td>xtxOkkxkkxbkkxbkxbkk</td>
		<td>.he.h..e.</td>
		<td>.he.U.he.</td>
		<td>.he.U.he.</td>
		<td>.he.U.he.</td>
		<td>.hU.U.e.he.</td>
		<td>.he.U.he.</td>
		<td>.he.U.he.</td>
		<td>.he.U.he.</td>
		<td>.he.U.he.</td>
		<td>.he.U.he.</td>
	</tr>
	<tr>
		<td>rrUU</td>
		<td>.re.rU.U.</td>
		<td>xtxOkkxkkxbkkxbkxbkk</td>
		<td>.re.rU.UU.</td>
		<td>.re.rU.U.</td>
		<td>.re.rU.U.</td>
		<td>.re.rU.U.</td>
		<td>.re.rU.U.U.</td>
		<td>.re.rU.U.</td>
		<td>.re.rU.U.</td>
		<td>.re.rU.U.</td>
		<td>.re.rU.U.</td>
		<td>.re.rU.U.</td>
	</tr>
	<tr>
		<td>gr</td>
		<td>.ge.re.</td>
		<td>fddddddddddddddddddd</td>
		<td>.ge.re.</td>
		<td>.ge.re.</td>
		<td>.ge.re.</td>
		<td>.ge.re.</td>
		<td>.ge.re.</td>
		<td>.ge.re.</td>
		<td>.ge.re.</td> 
		<td>.ge.re.</td>
		<td>.ge.re.</td>
		<td>.ge.re.</td>
	</tr>
	<tr>
		<td>grreg</td>
		<td>.ge.re.re.ge.</td>
		<td>fddddddddddddddddddd</td>
		<td>.ge.re.ge.ge.</td>
		<td>.ge.re.re.ge.</td>
		<td>.ge.re.re.ge.</td>
		<td>.ge.re.ge.ge.</td>
		<td>.ge.re.re.ge.ge.</td>
		<td>.ge.re.re.ge.</td>
		<td>.ge.re.re.ge.ge.</td>
		<td>.ge.re.re.ge.</td>
		<td>.ge.re.re.ge.</td>
		<td>.ge.re.re.ge.</td>
	</tr>
	<tr>
		<td>UeerU</td>
		<td>.U.e.e.rU.</td>
		<td>xtxOkkxkkxbkkxbkxbkk</td>
		<td>.U.U.rU.U.</td>
		<td>.U.e.e.rU.</td>
		<td>.U.e.e.rU.</td>
		<td>.U.e.e.rU.</td>
		<td>.U.e.e.rU.</td>
		<td>.U.e.e.rU.</td>
		<td>.U.e.e.rU.</td>
		<td>.U.e.e.rU.</td>
		<td>.U.e.e.rU.</td> 
		<td>.U.e.e.rU.</td> 
	</tr>
</table>

0,1,3,2
<table>
	<tr>
		<th>input</th>
		<th>correct output</th>
		<th>0 iterations</th>
		<th>1000 iterations</th>
		<th>2000 iterations</th>
		<th>3000 iterations</th>
		<th>4000 iterations</th>
		<th>5000 iterations</th>
		<th>6000 iterations</th>
		<th>7000 iterations</th>
		<th>8000 iterations</th>
		<th>9000 iterations</th>
		<th>10000 iterations</th>
	</tr>
	<tr>
		<td>Iulu</td>
		<td>.lu.</td>
		<td>ssssssssssssssssssss</td>
		<td>.lu.</td>
		<td>.lu.</td>
		<td>.lu.</td>
		<td>.lu.</td>
		<td>.lu.</td>
		<td>.lu.</td>
		<td>.lu.</td>
		<td>.lu.</td>
		<td>.lu.</td>
		<td>.lu.</td>
	</tr>
	<tr>
		<td>lIj</td>
		<td>.lI.</td>
		<td>jfffffffffffffffffff</td>
		<td>.lI.</td>
		<td>.lI.</td>
		<td>.lI.</td>
		<td>.lI.</td>
		<td>.lI.</td>
		<td>.lI.</td>
		<td>.lI.</td>
		<td>.lI.</td>
		<td>.lI.</td>
		<td>.lI.</td>
	</tr>
	<tr>
		<td>udub</td>
		<td>.du.</td>
		<td>jfffffffffffffffffff</td>
		<td>.du.</td>
		<td>.du.</td>
		<td>.du.</td>
		<td>.du.</td>
		<td>.du.</td>
		<td>.du.</td>
		<td>.du.</td>
		<td>.du.</td>
		<td>.du.</td>
		<td>.du.</td>
	</tr>
	<tr>
		<td>uIIII</td>
		<td></td>
		<td>kmffffffffffffffffff</td>
		<td></td>
		<td></td>
		<td></td>
		<td></td>
		<td></td>
		<td></td>
		<td></td>
		<td></td>
		<td></td>
		<td></td>
	</tr>
	<tr>
		<td>jIu</td>
		<td>.ju.</td>
		<td>kmffffffffffffffffff</td>
		<td>.ju.</td>
		<td>.ju.</td>
		<td>.ju.</td>
		<td>.ju.</td>
		<td>.ju.</td>
		<td>.ju.</td>
		<td>.ju.</td>
		<td>.ju.</td>
		<td>.ju.</td>
		<td>.ju.</td>
	</tr>
	<tr>
		<td>uIuIu</td>
		<td></td>
		<td>ssssssssssssssssssss</td>
		<td></td> 
		<td></td>
		<td></td>
		<td></td>
		<td></td>
		<td></td>
		<td></td>
		<td></td>
		<td></td>
		<td></td>
	</tr>
	<tr>
		<td>bbudI</td>
		<td>.bu.dI.</td>
		<td>kmffffffffffffffffff</td>
		<td>.bu.dI.</td>
		<td>.bu.dI.</td>
		<td>.bu.dI.</td>
		<td>.bu.dI.</td>
		<td>.bu.dI.</td>
		<td>.bu.dI.</td>
		<td>.bu.dI.</td>
		<td>.bu.dI.</td>
		<td>.bu.dI.</td>
		<td>.bu.dI.</td>
	</tr>
	<tr>
		<td>Iubjj</td>
		<td></td>
		<td>jfffffffffffffffffff</td>
		<td></td>
		<td></td>
		<td></td>
		<td></td>
		<td></td>
		<td></td>
		<td></td>
		<td></td>
		<td></td>
		<td></td>
	</tr>
	<tr>
		<td>II</td>
		<td></td>
		<td>kmffffffffffffffffff</td>
		<td></td>
		<td></td>
		<td></td>
		<td></td>
		<td></td>
		<td></td>
		<td></td>
		<td></td>
		<td></td>
		<td></td>
	</tr>
	<tr>
		<td>juIb</td>
		<td>.jI.</td>
		<td>kmffffffffffffffffff</td>
		<td>.jI.</td>
		<td>.jI.</td>
		<td>.jI.</td>
		<td>.jI.</td>
		<td>.jI.</td>
		<td>.jI.</td>
		<td>.jI.</td>
		<td>.jI.</td>
		<td>.jI.</td>
		<td>.jI.</td>
	</tr>
</table>

0,3,2,1
<table>
	<tr>
		<th>input</th>
		<th>correct output</th>
		<th>0 iterations</th>
		<th>1000 iterations</th>
		<th>2000 iterations</th>
		<th>3000 iterations</th>
		<th>4000 iterations</th>
		<th>5000 iterations</th>
		<th>6000 iterations</th>
		<th>7000 iterations</th>
		<th>8000 iterations</th>
		<th>9000 iterations</th>
		<th>10000 iterations</th>
	</tr>
	<tr>
		<td>fIxa</td>
		<td>.fI.xa.</td>
		<td>g.xwiiss.ligs.xis.is</td>
		<td>.fI.fI..</td>
		<td>.fI..a.</td>
		<td>.fI.xa.</td>
		<td>.fI.xa.</td>
		<td>.fI.xa.</td>
		<td>.fI.xa.</td>
		<td>.fI.xa.</td>
		<td>.fI.xa.</td>
		<td>.fI.xa.</td>
		<td>.fI.xa.</td>
	</tr>
	<tr>
		<td>ama</td>
		<td>.ma.</td>
		<td>..is.islg.xwiisseeee</td>
		<td>.ma.</td>
		<td>.ma.</td>
		<td>.ma.</td>
		<td>.ma.</td>
		<td>.ma.</td>
		<td>.ma.</td>
		<td>.ma.</td>
		<td>.ma.</td>
		<td>.ma.</td>
		<td>.ma.</td>
	</tr>
	<tr>
		<td>xxx</td>
		<td></td>
		<td>Oeg.xwiisseeeeeexwii</td>
		<td></td>
		<td></td>
		<td></td>
		<td></td>
		<td></td>
		<td></td>
		<td></td>
		<td></td>
		<td></td>
		<td></td>
		<td></td>
		<td></td>
	</tr>
	<tr>
		<td>faxII</td>
		<td>.fa.xI.</td>
		<td>eg.xwiisseeeeeexwiis</td>
		<td>.fI..I.</td>
		<td>.fI.fI.</td>
		<td>.fa.xI.</td>
		<td>.fa.xI.</td>
		<td>.fa.xI.</td>
		<td>.fa.xI.</td>
		<td>.fa.xI.</td>
		<td>.fa.xI.</td>
		<td>.fa.xI.</td>
		<td>.fa.xI.</td>
	</tr>
	<tr>
		<td>axIII</td>
		<td>.xI.</td>
		<td>egk.xiiss.ligs.xis.i</td>
		<td>.xI..II.</td>
		<td>.xI.</td>
		<td>.xI.</td>
		<td>.xI.</td>
		<td>.xI.</td>
		<td>.xI.</td>
		<td>.xI.</td>
		<td>.xI.</td>
		<td>.xI.</td>
		<td>.xI.</td>
	</tr>
	<tr>
		<td>axI</td>
		<td>.xI.</td>
		<td>eg.xwiisseeeeeexwiis</td>
		<td>.xI.</td>
		<td>.xI.</td>
		<td>.xI.</td>
		<td>.xI.</td>
		<td>.xI.</td>
		<td>.xI.</td>
		<td>.xI.</td>
		<td>.xI.</td>
		<td>.xI.</td>
		<td>.xI.</td>
	</tr>
	<tr>
		<td>Ifaaa</td>
		<td>.fa.</td>
		<td>..xiiss.ligs.xis.isl</td>
		<td>.fa.</td>
		<td>.fa.</td>
		<td>.fa.</td>
		<td>.fa.</td>
		<td>.fa.</td>
		<td>.fa.</td>
		<td>.fa.</td>
		<td>.fa.</td>
		<td>.fa.</td>
		<td>.fa.</td>
	</tr>
	<tr>
		<td>xdId</td>
		<td>.dId.</td>
		<td>Ik.islg.xiiss.ligs.x</td>
		<td>.dId.</td>
		<td>.dId.</td>
		<td>.dId.</td>
		<td>.dId.</td>
		<td>.dId.</td>
		<td>.dId.</td>
		<td>.dId.</td>
		<td>.dId.</td>
		<td>.dId.</td>
		<td>.dId.</td>
	</tr>
	<tr>
		<td>IxfdI</td>
		<td>.dI.</td>
		<td>f.l.iiss.ligs.xis.is</td>
		<td>.dI.</td>
		<td>.dI.</td>
		<td>.dI.</td>
		<td>.dI.</td>
		<td>.dI.</td>
		<td>.dI.</td>
		<td>.dI.</td>
		<td>.dI.</td>
		<td>.dI.</td>
		<td>.dI.</td>
	</tr>
	<tr>
		<td>mxma</td>
		<td>.ma.</td>
		<td>..is.islg.xwiisseeee</td>
		<td>.ma.</td>
		<td>.ma.</td>
		<td>.ma.</td>
		<td>.ma.</td>
		<td>.ma.</td>
		<td>.ma.</td>
		<td>.ma.</td>
		<td>.ma.</td>
		<td>.ma.</td>
		<td>.ma.</td>
	</tr>
</table>

	<br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br>

	<canvas id="myCanvas" style="border-style: solid;" height=300 width=300px></canvas>

<div class="slidecontainer">
  <input type="range" min="1" max="100" value="50" class="slider" id="myRange">
  <p>Value: <span id="demo"></span></p>
</div>

</div>



<br>
<br>
<br>
<br>
<br>





	<div id="printplace"></div>

	<div id="printplaceb"></div>
	<div id="printplacec"></div>
<div id="printplaced"></div>


<h3>Generalization</h3>

Use multiple tabs: Click on the type of generalization you want to study.

<h3>Sandbox</h3>

People can enter their own training set and test set and see how the model learns it.


</section>
</div> <!--End of content wrapper-->

<script src="metaug_js/maml_weights_js_variables.js"></script>
<script src="metaug_js/charinddicts.js"></script>
<script src="metaug_js/tf_weights.js"></script>
<script src="metaug_js/ioc.js"></script>
<script>

var showing_adv = true;
function toggleshowadv() {
	if (showing_adv) {
		document.getElementById("advancedsettings").style.display = "none";
		showing_adv = false;
		document.getElementById("advbtntxt").innerHTML = "Show advanced settings";
	} else {
		document.getElementById("advancedsettings").style.display = "block";
		showing_adv = true;
		document.getElementById("advbtntxt").innerHTML = "Hide advanced settings";
	}
} 

toggleshowadv();


this_counter = 0;

manual_ranking = "";
manual_vowel_inventory = [];
manual_consonant_inventory = [];
all_vowels = ["a", "e", "i", "o", "u", "biga", "bige", "bigi", "bigo", "bigu"];
all_consonants = ["b", "c", "d", "f", "g", "h", "j", "k", "l", "m", "n", "p", "q", "r", "s", "t", "v", "w", "x", "z"];


function ranktoggle(ranking) {
	manual_ranking = ranking;
	document.getElementById("rankbtn").innerHTML = key2ranking[ranking];

	document.getElementById("langdesc").innerHTML = key2description[ranking].replace("CONS", manual_ep_cons).replace("VOW", manual_ep_vow);
	renew_language();	
}

function vtoggle(vow) {
	if (!manual_vowel_inventory.includes(vow)) {
		manual_vowel_inventory.push(vow);
		document.getElementById("btn" + vowel_dict[vow]).style.backgroundColor = "blue";
		document.getElementById("btn" + vowel_dict[vow]).style.color = "white";
	} else {

		split_point = manual_vowel_inventory.indexOf(vow);
		manual_vowel_inventory = manual_vowel_inventory.slice(0,split_point).concat(manual_vowel_inventory.slice(split_point + 1));
		document.getElementById("btn" + vowel_dict[vow]).style.backgroundColor = "white";
		document.getElementById("btn" + vowel_dict[vow]).style.color = "black";
	}




	for (v_index = 0; v_index < all_vowels.length; v_index++) {
		vow = all_vowels[v_index];
		document.getElementById("btnep" + vowel_dict[vow]).style.backgroundColor = "white";
		document.getElementById("btnep" + vowel_dict[vow]).style.color =
 "black";
		document.getElementById("btnep" + vowel_dict[vow]).style.display = "none";
	}

	for (vm_index = 0; vm_index < manual_vowel_inventory.length; vm_index++) {
		vow = vowel_dict[manual_vowel_inventory[vm_index]];
		document.getElementById("btnep" + vowel_dict[vow]).style.display = "inline";
	}

	if (!manual_vowel_inventory.includes(manual_ep_vow)) {
		manual_ep_vow = choice(manual_vowel_inventory);
	}

	document.getElementById("btnep" + vowel_dict[manual_ep_vow]).style.backgroundColor = "blue";
	document.getElementById("btnep" + vowel_dict[manual_ep_vow]).style.color =
 "white";


	renew_language();


}

function ctoggle(cons) {
	if (!manual_consonant_inventory.includes(cons)) {
		manual_consonant_inventory.push(cons);
		document.getElementById("btn" + cons).style.backgroundColor = "blue";
		document.getElementById("btn" + cons).style.color = "white";
	} else {

		split_point = manual_consonant_inventory.indexOf(cons);
		manual_consonant_inventory = manual_consonant_inventory.slice(0,split_point).concat(manual_consonant_inventory.slice(split_point + 1));
		document.getElementById("btn" + cons).style.backgroundColor = "white";
		document.getElementById("btn" + cons).style.color = "black";
	}




	for (c_index = 0; c_index < all_consonants.length; c_index++) {
		cons = all_consonants[c_index];
		document.getElementById("btnep" + cons).style.backgroundColor = "white";
		document.getElementById("btnep" + cons).style.color = "black";
		document.getElementById("btnep" + cons).style.display = "none";
	}

	for (cm_index = 0; cm_index < manual_consonant_inventory.length; cm_index++) {
		cons = manual_consonant_inventory[cm_index];
		document.getElementById("btnep" + cons).style.display = "inline";
	}

	if (!manual_consonant_inventory.includes(manual_ep_cons)) {
		manual_ep_cons = choice(manual_consonant_inventory);
	}

	document.getElementById("btnep" + manual_ep_cons).style.backgroundColor = "blue";
	document.getElementById("btnep" + manual_ep_cons).style.color =
 "white";


	renew_language();


}

function ceptoggle(cons) {

	for (cn = 0; cn < manual_consonant_inventory.length; cn++) {
		first_c = manual_consonant_inventory[cn];
		document.getElementById("btnep" + first_c).style.color = "black";
		document.getElementById("btnep" + first_c).style.backgroundColor = "white";
	}
	
	document.getElementById("btnep" + cons).style.color = "white";
	document.getElementById("btnep" + cons).style.backgroundColor = "blue";

	manual_ep_cons = cons;

	renew_language();
}

function veptoggle(vow) {

	for (vn = 0; vn < manual_vowel_inventory.length; vn++) {
		first_v = vowel_dict[manual_vowel_inventory[vn]];
		document.getElementById("btnep" + first_v).style.color = "black";
		document.getElementById("btnep" + first_v).style.backgroundColor = "white";
	}
	document.getElementById("btnep" + vowel_dict[vow]).style.color = "white";
	document.getElementById("btnep" + vowel_dict[vow]).style.backgroundColor = "blue";

	manual_ep_vow = vow;

	renew_language();
}



vowel_dict = {
	"a" : "a",
	"e" : "e",
	"i" : "i",
	"o" : "o",
	"u" : "u",
	"A" : "biga",
	"E" : "bige",
	"I" : "bigi",
	"O" : "bigo",
	"U" : "bigu",
	"biga" : "biga",
	"bige" : "bige",
	"bigi" : "bigi",
	"bigo" : "bigo",
	"bigu" : "bigu"	
}

function random_language() {

	new_lang = make_task(choice(rankings), all_input_outputs, n_train=200, n_dev=1, n_test=6);


	training_set = new_lang[0];
	dev_set = new_lang[1];
	test_set = new_lang[2];
	new_vinv = new_lang[3];
	new_cinv = new_lang[4];

	test_set_firsts = [];
	for (tsf = 0; tsf<test_set.length; tsf++) {
    	test_set_firsts.push(test_set[tsf][0]);
	}

	manual_ranking = new_lang[5];
	manual_vowel_inventory = new_vinv;
	manual_consonant_inventory = new_cinv;
	manual_ep_vow = new_vinv[0];
	manual_ep_cons = new_cinv[0];



	for (spqr = 0; spqr < test_set.length; spqr++) {
		document.getElementById("inb" + (spqr + 1)).innerHTML = nullify(test_set[spqr][0]);
		document.getElementById("corrb" + (spqr + 1)).innerHTML = nullify(test_set[spqr][1]);
	}


	for (v_index = 0; v_index < all_vowels.length; v_index++) {
		vow = all_vowels[v_index];
		document.getElementById("btn" + vow).style.backgroundColor = "white";
		document.getElementById("btn" + vow).style.color = "black";
		document.getElementById("btnep" + vow).style.display = "none";
	}

	for (vm_index = 0; vm_index < manual_vowel_inventory.length; vm_index++) {
		vow = vowel_dict[manual_vowel_inventory[vm_index]];
		document.getElementById("btn" + vow).style.backgroundColor = "blue";
		document.getElementById("btn" + vow).style.color = "white";
		document.getElementById("btnep" + vow).style.display = "inline";
	}
	document.getElementById("btnep" + vowel_dict[manual_ep_vow]).style.backgroundColor = "blue";
	document.getElementById("btnep" + vowel_dict[manual_ep_vow]).style.color =
 "white";


	for (c_index = 0; c_index < all_consonants.length; c_index++) {
		cons = all_consonants[c_index];
		document.getElementById("btn" + cons).style.backgroundColor = "white";
		document.getElementById("btn" + cons).style.color = "black";
		document.getElementById("btnep" + cons).style.display = "none";
	}

	for (cm_index = 0; cm_index < manual_consonant_inventory.length; cm_index++) {
		cons = manual_consonant_inventory[cm_index];
		document.getElementById("btn" + cons).style.backgroundColor = "blue";
		document.getElementById("btn" + cons).style.color = "white";
		document.getElementById("btnep" + cons).style.display = "inline";
	
	}

	document.getElementById("btnep" + manual_ep_cons).style.backgroundColor = "blue";
	document.getElementById("btnep" + manual_ep_cons).style.color = "white";


	reset_weights();
	
	  preds = tf.tidy(() => seq2seq(test_set_firsts)[0]);
	  for (lmnop = 0; lmnop < test_set.length; lmnop++) {
			pred = toz(preds[lmnop])
			if (pred == test_set[lmnop][1]) {
				font_color = "green";
			} else {
				font_color = "red";
			}
			document.getElementById("metaoutb" + (lmnop + 1)).innerHTML = "<span style='color: " + font_color + ";'>" + nullify(pred) + "</span>";
	  }


	  preds = tf.tidy(() => seq2seqb(test_set_firsts)[0]);
	  for (lmnop = 0; lmnop < test_set.length; lmnop++) {
			pred = toz(preds[lmnop]);
			if (pred == test_set[lmnop][1]) {
                font_color = "green";
            } else {
                font_color = "red";
            }


			document.getElementById("randomoutb" + (lmnop + 1)).innerHTML = "<span style='color: " + font_color + ";'>" + nullify(pred) + "</span>";
	  }


	document.getElementById("rankbtn").innerHTML = key2ranking[manual_ranking];
	document.getElementById("langdesc").innerHTML = key2description[manual_ranking].replace("CONS", manual_ep_cons).replace("VOW", manual_ep_vow);

	this_counter = 0;
	document.getElementById("traincount").innerHTML = this_counter;

	seen_training = "";
    document.getElementById("trainingexamplelist").innerHTML = seen_training;
	document.getElementById("trainingexamplelist").scrollTop = document.getElementById("trainingexamplelist").scrollHeight;

	document.getElementById("oneexamplebtn").disabled = false;

	fitfitfitfirst(seq2seq, 'meta', add_train=true);
	fitfitfitfirst(seq2seqb, 'random');

}


function renew_language() {
	ind_ep_vow = manual_vowel_inventory.indexOf(manual_ep_vow);

	manual_ep_vow_list = [manual_ep_vow];
	manual_vowel_inventory = manual_ep_vow_list.concat(manual_vowel_inventory.slice(0,ind_ep_vow).concat(manual_vowel_inventory.slice(ind_ep_vow + 1)));

	ind_ep_cons = manual_consonant_inventory.indexOf(manual_ep_cons);

	manual_ep_cons_list = [manual_ep_cons];
	manual_consonant_inventory = manual_ep_cons_list.concat(manual_consonant_inventory.slice(0,ind_ep_cons).concat(manual_consonant_inventory.slice(ind_ep_cons + 1)));



	new_lang = make_task(manual_ranking, all_input_outputs, n_train=200, n_dev=1, n_test=6, v_list=manual_vowel_inventory, c_list=manual_consonant_inventory);

	training_set = new_lang[0];
	dev_set = new_lang[1];
	test_set = new_lang[2];
	test_set_firsts = [];
	for (tsf = 0; tsf<test_set.length; tsf++) {
		test_set_firsts.push(test_set[tsf][0]);
	}
	for (spqr = 0; spqr < test_set.length; spqr++) {
		document.getElementById("inb" + (spqr + 1)).innerHTML = nullify(test_set[spqr][0]);
		document.getElementById("corrb" + (spqr + 1)).innerHTML = nullify(test_set[spqr][1]);
	}


	for (v_index = 0; v_index < all_vowels.length; v_index++) {
		vow = all_vowels[v_index];
		document.getElementById("btn" + vow).style.backgroundColor = "white";
		document.getElementById("btn" + vow).style.color = "black";
		document.getElementById("btnep" + vow).style.display = "none";
	}

	for (vm_index = 0; vm_index < manual_vowel_inventory.length; vm_index++) {
		vow = vowel_dict[manual_vowel_inventory[vm_index]];
		document.getElementById("btn" + vow).style.backgroundColor = "blue";
		document.getElementById("btn" + vow).style.color = "white";
		document.getElementById("btnep" + vow).style.display = "inline";
	}
	document.getElementById("btnep" + vowel_dict[manual_ep_vow]).style.backgroundColor = "blue";
	document.getElementById("btnep" + vowel_dict[manual_ep_vow]).style.color =
 "white";


	for (c_index = 0; c_index < all_consonants.length; c_index++) {
		cons = all_consonants[c_index];
		document.getElementById("btn" + cons).style.backgroundColor = "white";
		document.getElementById("btn" + cons).style.color = "black";
		document.getElementById("btnep" + cons).style.display = "none";
	}

	for (cm_index = 0; cm_index < manual_consonant_inventory.length; cm_index++) {
		cons = manual_consonant_inventory[cm_index];
		document.getElementById("btn" + cons).style.backgroundColor = "blue";
		document.getElementById("btn" + cons).style.color = "white";
		document.getElementById("btnep" + cons).style.display = "inline";
	
	}

	document.getElementById("btnep" + manual_ep_cons).style.backgroundColor = "blue";
	document.getElementById("btnep" + manual_ep_cons).style.color = "white";


	reset_weights();
	
	  preds = tf.tidy(() => seq2seq(test_set_firsts)[0]);
	  for (lmnop = 0; lmnop < test_set.length; lmnop++) {
			pred = toz(preds[lmnop])
			if (pred == test_set[lmnop][1]) {
				font_color = "green";
			} else {
				font_color = "red";
			}
			document.getElementById("metaoutb" + (lmnop + 1)).innerHTML = "<span style='color: " + font_color + ";'>" + nullify(pred) + "</span>";
	  }


	  preds = tf.tidy(() => seq2seqb(test_set_firsts)[0]);
	  for (lmnop = 0; lmnop < test_set.length; lmnop++) {
			pred = toz(preds[lmnop]);
			if (pred == test_set[lmnop][1]) {
                font_color = "green";
            } else {
                font_color = "red";
            }


			document.getElementById("randomoutb" + (lmnop + 1)).innerHTML = "<span style='color: " + font_color + ";'>" + nullify(pred) + "</span>";
	  }


	document.getElementById("rankbtn").innerHTML = key2ranking[manual_ranking];
	document.getElementById("langdesc").innerHTML = key2description[manual_ranking].replace("CONS", manual_ep_cons).replace("VOW", manual_ep_vow);

	this_counter = 0;
	document.getElementById("traincount").innerHTML = this_counter;

	seen_training = "";
    document.getElementById("trainingexamplelist").innerHTML = seen_training;
	document.getElementById("trainingexamplelist").scrollTop = document.getElementById("trainingexamplelist").scrollHeight;

	fitfitfitfirst(seq2seq, 'meta', add_train=true);
    fitfitfitfirst(seq2seqb, 'random');
}


function toz(inp) {
	if (inp.includes("Z")) {
		inp = inp.slice(0, inp.indexOf("Z"));
	}

	return inp;
}

function nullify(inp) {

	//if (inp.includes("Z")) {
	//	inp = inp.slice(0, inp.indexOf("Z"));
	//}

	if (inp === "") {
		return "&lt;empty&gt;";
	} else {
		return inp;
	}
}

function shuffle(array) {
  for (let i = array.length - 1; i > 0; i--) {
    let j = Math.floor(Math.random() * (i + 1)); // random index from 0 to i

    [array[i], array[j]] = [array[j], array[i]];
  }
}

function choice(array) {
	return array[Math.floor(Math.random() * array.length)];
}



function trf(x) {
	return true;
}




vowels = ['a', 'e', 'i', 'o', 'u', 'A', 'E', 'I', 'O', 'U'];
consonants = ['b', 'c', 'd', 'f', 'g', 'h', 'j', 'k', 'l', 'm', 'n', 'p', 'q', 'r', 's', 't', 'v', 'w', 'x', 'z'];

function phoneme_inventory(nc=null, nv=null) {
	if (nc == null) {
		nc = Math.floor(Math.random() * 3) + 2;
	}

	if (nv == null) {
		nv = Math.floor(Math.random() * 3) + 2;
	}

	shuffle(vowels);
	shuffle(consonants);

	v_inv = vowels.slice(0,nv);
	c_inv = consonants.slice(0,nc);	

	return [v_inv, c_inv];

}


function output_string(inp, outp, v_list, c_list, steps=None, change_one=False, change_all=False) {
	outp_no_periods = outp.replace(/\./g, "");
	inp_phonemes = [];
	for (i = 0; i < inp.length; i++) {
		thischar = inp[i];
		if (thischar == "C") {
			inp_phonemes.push(choice(c_list));
		} else {
			inp_phonemes.push(choice(v_list));
		}
	}

	inp_word = inp_phonemes.join("");
	if (change_one) {
		inp_word = replace_one(inp_word, v_list, c_list);
	} else if (change_all) {
		inp_word = replace_all(inp_word, v_list, c_list);
	}

	inp_phonemes = inp_word;

	outp_phonemes = [];
	indi = 0;
	indo = 0;

	for (j = 0; j < steps.length; j++) {
		stp = steps[j];
		if (stp == "next") {
			outp_phonemes.push(inp_phonemes[indi]);
			indi++;
			indo++;
		}
		if (stp == "del") {
			indi++;
		}
		if (stp == "ins") {
			if (outp_no_periods[indo] == "C") {
				outp_phonemes.push(c_list[0]);
			} else {
				outp_phonemes.push(v_list[0]);
			}
			indo += 1;
		}

	}

	outp_alignment = [];
	ind_al = 0;

	for (k = 0; k < outp.length; k++) {
		thischar = outp[k];
		if (thischar == ".") {
			outp_alignment.push(thischar);
		} else {
			outp_alignment.push(ind_al);
			ind_al++;
		}
	}

	outp_chars = [];
	for (q = 0; q < outp_alignment.length; q++) {
		elt = outp_alignment[q];
		if (elt == ".") {
			outp_chars.push(".");
		} else {
			outp_chars.push(outp_phonemes[elt]);
		}
	}

	outp_word = outp_chars.join("");
	return [inp_word, outp_word];

}
	




function make_task(ranking, all_input_outputs, n_train=10, n_dev=10, n_test=10, v_list=null, c_list=null, periods=true, input_filter_dev=trf, output_filter_dev=trf, input_filter_test=trf, output_filter_test=trf, input_filter_train=trf, output_filter_train=trf, abstract_input_filter_dev=trf, abstract_output_filter_dev=trf, abstract_input_filter_test=trf, abstract_output_filter_test=trf, abstract_input_filter_train=trf, abstract_output_filter_train=trf, replace_one_dev=false, replace_one_test=false, replace_one_train=false, replace_all_dev=false, replace_all_test=false, replace_all_train=false, artificial_io_list=null) {
	if (all_input_outputs != null) {
		io_list = all_input_outputs[ranking].slice();
	} else {
		io_list = artificial_io_list;
	}

	shuffle(io_list);

	if (v_list == null || c_list == null) {
		inv = phoneme_inventory();
		v_list = inv[0];
		c_list = inv[1];
	}

	train_pairs = [];
	dev_pairs = [];
	test_pairs = [];

	train_dict = {};
	dev_dict = {};
	test_dict = {};


	for (iqj = 0; iqj < n_dev; iqj++) {
		satisfied = false;
		while (!satisfied) {
			abstract = choice(io_list);

			if ((replace_one_train || replace_all_train) && abstract[0] == "") {
				continue;
			}
			candidate = output_string(abstract[0],abstract[1], v_list, c_list, steps=abstract[2], change_one=replace_one_train, change_all=replace_all_train);
			candidate_str = candidate[0] + candidate[1];


			if (!(candidate_str in dev_dict) && !(candidate_str in test_dict) && abstract_input_filter_train(abstract[0]) && abstract_output_filter_train(abstract[1].replace(/\./g, "")) && input_filter_train(candidate[0]) && output_filter_train(candidate[1].replace(/\./g, ""))) {
				satisfied = true;
				if (periods) {
					train_pairs.push(candidate);
				} else {
					train_pairs.push([candidate[0], candidate[1].replace(/\./g, "")]);
				}

				train_dict[candidate] = 1;

			}

			
		}


		satisfied = false;
		while (!satisfied) {
			abstract = choice(io_list);

			if ((replace_one_dev || replace_all_dev) && abstract[0] == "") {
				continue;
			}


			candidate = output_string(abstract[0],abstract[1], v_list, c_list, steps=abstract[2], change_one=replace_one_dev, change_all=replace_all_dev);

			if (!(candidate in train_dict) && !(candidate in test_dict) && abstract_input_filter_dev(abstract[0]) && abstract_output_filter_dev(abstract[1].replace(/\./g, "")) && input_filter_dev(candidate[0]) && output_filter_dev(candidate[1].replace(/\./g, ""))) {
				satisfied = true;

				if (periods) {
					dev_pairs.push(candidate);
				} else {
					dev_pairs.push([candidate[0], candidate[1].replace(/\./g, "")]);
				}

				dev_dict[candidate] = 1

			}

		}


		satisfied = false;
		while (!satisfied) {
			abstract = choice(io_list);

			if ((replace_one_test || replace_all_test) && abstract[0] == "") {	
				continue;
			}
			
			candidate = output_string(abstract[0],abstract[1], v_list, c_list, steps=abstract[2], change_one=replace_one_test, change_all=replace_all_test);

			if (!(candidate in train_dict) && !(candidate in dev_dict) && abstract_input_filter_test(abstract[0]) && abstract_output_filter_test(abstract[1].replace(/\./g, "")) && input_filter_test(candidate[0]) || output_filter_test(candidate[1].replace(/\./g, ""))) {
				satisfied = true; 

				if (periods) {
					test_pairs.push(candidate);
				} else {
					test__pairs.push([candidate[0], candidate[1].replace(/\./g, "")]);
				}

				test_dict[candidate] = 1;
			}

		}

	}



	for (iqk = 0; iqk < n_test - n_dev; iqk++) {
		satisfied = false;
		while (!satisfied) {
			abstract = choice(io_list);

			if ((replace_one_train || replace_all_train) && abstract[0] == "") {
				continue;
			}

			candidate = output_string(abstract[0],abstract[1], v_list, c_list, steps=abstract[2], change_one=replace_one_train, change_all=replace_all_train);

			if (!(candidate in dev_dict) && !(candidate in test_dict) && abstract_input_filter_train(abstract[0]) && abstract_output_filter_train(abstract[1].replace(/\./g, "")) && input_filter_train(candidate[0]) && output_filter_train(candidate[1].replace(/\./g, ""))) {
				satisfied = true;
				if (periods) {
					train_pairs.push(candidate);
				} else {
					train_pairs.push([candidate[0], candidate[1].replace(/\./g, "")]);
				}

				train_dict[candidate] = 1;

			}

			
		}

		satisfied = false;
		while (!satisfied) {
			abstract = choice(io_list);

			if ((replace_one_test || replace_all_test) && abstract[0] == "") {	
				continue;
			}
			
			candidate = output_string(abstract[0],abstract[1], v_list, c_list, steps=abstract[2], change_one=replace_one_test, change_all=replace_all_test);

			if (!(candidate in train_dict) && !(candidate in dev_dict) && abstract_input_filter_test(abstract[0]) && abstract_output_filter_test(abstract[1].replace(/\./g, "")) && input_filter_test(candidate[0]) && output_filter_test(candidate[1].replace(/\./g, ""))) {
				satisfied = true; 

				if (periods) {
					test_pairs.push(candidate);
				} else {
					test__pairs.push([candidate[0], candidate[1].replace(/\./g, "")]);
				}

				test_dict[candidate] = 1;
			}

		}

	}


	for (iql = 0; iql < n_train - n_test; iql++) {
		satisfied = false;
		while (!satisfied) {
			abstract = choice(io_list);

			if ((replace_one_train || replace_all_train) && abstract[0] == "") {
				continue;
			}

			candidate = output_string(abstract[0],abstract[1], v_list, c_list, steps=abstract[2], change_one=replace_one_train, change_all=replace_all_train);

			if (!(candidate in dev_dict) && !(candidate in test_dict) && abstract_input_filter_train(abstract[0]) && abstract_output_filter_train(abstract[1].replace(/\./g, "")) && input_filter_train(candidate[0]) && output_filter_train(candidate[1].replace(/\./g, ""))) {
				satisfied = true;
				if (periods) {
					train_pairs.push(candidate);
				} else {
					train_pairs.push([candidate[0], candidate[1].replace(/\./g, "")]);
				}

				train_dict[candidate] = 1;

			}

			
		}


	}


	return [train_pairs, dev_pairs, test_pairs, v_list, c_list, ranking];
	

}


//0 = onset
//1 = nocoda
//2 = max
//3 = dep


const key2ranking = {
	"(0, 1, 2, 3)" : "Onset, NoCoda, Max &#187; Dep",
	"(0, 1, 3, 2)" : "Onset, NoCoda, Dep &#187; Max",
	"(0, 3, 2, 1)" : "Onset, Dep &#187; Max &#187; NoCoda",
	"(1, 3, 2, 0)" : "NoCoda, Dep &#187;  Max &#187; Onset",
	"(0, 2, 3, 1)" : "Onset, Max &#187; Dep &#187; NoCoda",
	"(1, 2, 3, 0)" : "NoCoda, Max &#187; Dep &#187; Onset",
	"(3, 2, 0, 1)" : "Dep &#187; Max &#187; Onset, NoCoda",
	"(2, 3, 0, 1)" : "Max &#187; Dep &#187; Onset, NoCoda"
}

const key2description = {
	"(0, 1, 2, 3)" : "Insert <em>CONS</em> or <em>VOW</em>  as necessary to ensure that all syllables are of the form consonant-vowel; add periods to mark syllable boundaries.",
	"(0, 1, 3, 2)" : "Delete sounds as necessary to ensure that all syllables are of the form consonant-vowel; add periods to mark syllable boundaries.",
	"(0, 3, 2, 1)" : "Delete sounds as necessary to ensure that all syllables start with a consonant; add periods to mark syllable boundaries.",
	"(1, 3, 2, 0)" : "Delete sounds as necessary to ensure that all syllables end with a vowel; add periods to mark syllable boundaries.",
	"(0, 2, 3, 1)" : "Insert <em>CONS</em> and <em>VOW</em> as necessary to have all syllables start with a consonant and to make the output pronounceable; add periods to mark syllable boundaries.",
	"(1, 2, 3, 0)" : "Insert <em>VOW</em> as necessary to ensure that all syllables end with a vowel; add periods to mark syllable boundaries.",
	"(3, 2, 0, 1)" : "Delete sounds as necessary to ensure that the output is pronounceable, but otherwise change nothing; add periods to mark syllable boundaries.",
	"(2, 3, 0, 1)" : "Insert <em>VOW</em> as necessary to ensure that the output is pronounceable, but otherwise change nothing; add periods to mark syllable boundaries."
}



rankings = ["(2, 3, 0, 1)", "(3, 2, 0, 1)", "(1, 2, 3, 0)", "(0, 2, 3, 1)", "(1, 3, 2, 0)", "(0, 3, 2, 1)", "(0, 1, 3, 2)", "(0, 1, 2, 3)"]

new_lang = make_task(choice(rankings), all_input_outputs, n_train=100, n_dev=2, n_test=6);

training_set = new_lang[0];
dev_set = new_lang[1];
test_set = new_lang[2];
new_vinv = new_lang[3];
new_cinv = new_lang[4];

test_set_firsts = [];
for (tsf = 0; tsf<test_set.length; tsf++) {
    test_set_firsts.push(test_set[tsf][0]);
}

manual_ranking = new_lang[5];
manual_vowel_inventory = new_vinv;
manual_consonant_inventory = new_cinv;
manual_ep_vow = new_vinv[0];
manual_ep_cons = new_cinv[0];





this_input = word2embs(["zaza"]);
this_input2 = word2embs([".za.za"], sos=true);



var tf_emb_wg = tf.tensor2d(emb_wg, [34,10]);
var weights_emb_bias = tf.zeros([10]);
var tf_full_x = tf.variable(tf.tensor2d(full_x, [10,768]),trainable=true);
var tf_full_w = tf.variable(tf.tensor2d(full_w, [256,768]),trainable=true);
var tf_full_b = tf.variable(tf.tensor(full_b, [3,256]),trainable=true);
var tf_out_wg = tf.variable(tf.tensor(out_wg, [256,34]),trainable=true);
var tf_out_wb = tf.variable(tf.tensor(out_wb, [34]),trainable=true);
var tf_full_xd = tf.variable(tf.tensor2d(full_xd, [10,768]),trainable=true);
var tf_full_wd = tf.variable(tf.tensor2d(full_wd, [256,768]),trainable=true);
var tf_full_bd = tf.variable(tf.tensor(full_bd, [3,256]),trainable=true);



var xz = tf.variable(tf.slice(tf_full_x, [0,0], [10,256]));
var xr = tf.variable(tf.slice(tf_full_x, [0,256], [10,256]));
var xx = tf.variable(tf.slice(tf_full_x, [0,512], [10,256]));
var wz = tf.variable(tf.slice(tf_full_w, [0,0], [256,256]));
var wr = tf.variable(tf.slice(tf_full_w, [0,256], [256,256]));
var wx = tf.variable(tf.slice(tf_full_w, [0,512], [256,256]));
var bz = tf.variable(tf.slice(tf_full_b, [0,0], [1,256]));
var br = tf.variable(tf.slice(tf_full_b, [1,0], [1,256]));
var bx = tf.variable(tf.slice(tf_full_b, [2,0], [1,256]));

var xzd = tf.variable(tf.slice(tf_full_xd, [0,0], [10,256]));
var xrd = tf.variable(tf.slice(tf_full_xd, [0,256], [10,256]));
var xxd = tf.variable(tf.slice(tf_full_xd, [0,512], [10,256]));
var wzd = tf.variable(tf.slice(tf_full_wd, [0,0], [256,256]));
var wrd = tf.variable(tf.slice(tf_full_wd, [0,256], [256,256]));
var wxd = tf.variable(tf.slice(tf_full_wd, [0,512], [256,256]));
var bzd = tf.variable(tf.slice(tf_full_bd, [0,0], [1,256]));
var brd = tf.variable(tf.slice(tf_full_bd, [1,0], [1,256]));
var bxd = tf.variable(tf.slice(tf_full_bd, [2,0], [1,256]));

var emb = tf.variable(tf_emb_wg);

var wout = tf.variable(tf_out_wg);
var bout = tf.variable(tf_out_wb);







var xzb = tf.variable(tf.randomNormal([10,256]));
var xrb = tf.variable(tf.randomNormal([10,256]));
var xxb = tf.variable(tf.randomNormal([10,256]));
var wzb = tf.variable(tf.randomNormal([256,256]));
var wrb = tf.variable(tf.randomNormal([256,256]));
var wxb = tf.variable(tf.randomNormal([256,256]));
var bzb = tf.variable(tf.randomNormal([1,256]));
var brb = tf.variable(tf.randomNormal([1,256]));
var bxb = tf.variable(tf.randomNormal([1,256]));

var xzdb = tf.variable(tf.randomNormal([10,256]));
var xrdb = tf.variable(tf.randomNormal([10,256]));
var xxdb = tf.variable(tf.randomNormal([10,256]));
var wzdb = tf.variable(tf.randomNormal([256,256]));
var wrdb = tf.variable(tf.randomNormal([256,256]));
var wxdb = tf.variable(tf.randomNormal([256,256]));
var bzdb = tf.variable(tf.randomNormal([1,256]));
var brdb = tf.variable(tf.randomNormal([1,256]));
var bxdb = tf.variable(tf.randomNormal([1,256]));

var embb = tf.variable(tf.randomNormal([34,10]));

var woutb = tf.variable(tf.randomNormal([256,34]));
var boutb = tf.variable(tf.randomNormal([34]));










function reset_weights() {


	xz = tf.variable(tf.slice(tf_full_x, [0,0], [10,256]));
	xr = tf.variable(tf.slice(tf_full_x, [0,256], [10,256]));
	xx = tf.variable(tf.slice(tf_full_x, [0,512], [10,256]));
	wz = tf.variable(tf.slice(tf_full_w, [0,0], [256,256]));
	wr = tf.variable(tf.slice(tf_full_w, [0,256], [256,256]));
	wx = tf.variable(tf.slice(tf_full_w, [0,512], [256,256]));
	bz = tf.variable(tf.slice(tf_full_b, [0,0], [1,256]));
	br = tf.variable(tf.slice(tf_full_b, [1,0], [1,256]));
	bx = tf.variable(tf.slice(tf_full_b, [2,0], [1,256]));

	xzd = tf.variable(tf.slice(tf_full_xd, [0,0], [10,256]));
	xrd = tf.variable(tf.slice(tf_full_xd, [0,256], [10,256]));
	xxd = tf.variable(tf.slice(tf_full_xd, [0,512], [10,256]));
	wzd = tf.variable(tf.slice(tf_full_wd, [0,0], [256,256]));
	wrd = tf.variable(tf.slice(tf_full_wd, [0,256], [256,256]));
	wxd = tf.variable(tf.slice(tf_full_wd, [0,512], [256,256]));
	bzd = tf.variable(tf.slice(tf_full_bd, [0,0], [1,256]));
	brd = tf.variable(tf.slice(tf_full_bd, [1,0], [1,256]));
	bxd = tf.variable(tf.slice(tf_full_bd, [2,0], [1,256]));

	emb = tf.variable(tf_emb_wg);

	wout = tf.variable(tf_out_wg);
	bout = tf.variable(tf_out_wb);







	xzb = tf.variable(tf.randomNormal([10,256]));
	xrb = tf.variable(tf.randomNormal([10,256]));
	xxb = tf.variable(tf.randomNormal([10,256]));
	wzb = tf.variable(tf.randomNormal([256,256]));
	wrb = tf.variable(tf.randomNormal([256,256]));
	wxb = tf.variable(tf.randomNormal([256,256]));
	bzb = tf.variable(tf.randomNormal([1,256]));
	brb = tf.variable(tf.randomNormal([1,256]));
	bxb = tf.variable(tf.randomNormal([1,256]));

	xzdb = tf.variable(tf.randomNormal([10,256]));
	xrdb = tf.variable(tf.randomNormal([10,256]));
	xxdb = tf.variable(tf.randomNormal([10,256]));
	wzdb = tf.variable(tf.randomNormal([256,256]));
	wrdb = tf.variable(tf.randomNormal([256,256]));
	wxdb = tf.variable(tf.randomNormal([256,256]));
	bzdb = tf.variable(tf.randomNormal([1,256]));
	brdb = tf.variable(tf.randomNormal([1,256]));
	bxdb = tf.variable(tf.randomNormal([1,256]));

	embb = tf.variable(tf.randomNormal([34,10]));

	woutb = tf.variable(tf.randomNormal([256,34]));
	boutb = tf.variable(tf.randomNormal([34]));

}





var these_zeros = [];
var these_ones = [];
for (xkcd = 0; xkcd < 256; xkcd++) {
	these_zeros.push(0);
	these_ones.push(1);
}





var seen_training = "";

function make_one_hot(index) {
    onehot_vec = [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0];
    onehot_vec[index] = 1;
    return onehot_vec;  
}
function make_one_hot_seq(word, eos=true) {
    length_word = word.length;
    onehot_vec = []

    for (ind = 0; ind < length_word; ind++) {
        charnum = char2ind[word[ind]];
        onehot_vec = onehot_vec.concat(make_one_hot(charnum));
    }

    if (eos) {
        charnum = char2ind["EOS"];
        onehot_vec = onehot_vec.concat(make_one_hot(charnum));
        length_word += 1;
    }

    if (eos && length_word == 1) {
        charnum = char2ind["EOS"];
        onehot_vec = onehot_vec.concat(make_one_hot(charnum));
        length_word += 1;
    }


    return tf.tensor3d(onehot_vec, [1,length_word,34]);
} 

function output_to_string(outp_logits) {
    topks = tf.topk(outp_logits)["indices"];
    topks_usable = topks.dataSync();
    
    out_string = "";
    for (i = 0; i < topks_usable.length; i++) {
        out_string = out_string + ind2char[topks_usable[i]];
    }

    return out_string;
}

function generate_output(model, inp, secondguy) {
    done = false;

    inp1 = word2embs([inp]);
    inp2 = word2embs([""], sos=true);
    //inp2 = word2embs([secondguy.substring(0, training_set[ijk][1].length)], sos=true)

    counter = 0;
    while (!done) {
        counter += 1;
        out_string = output_to_string(model.predict([inp1, inp2]));
        if (out_string[out_string.length - 1] == "Z") {
            done = true;
        } else if (counter > 15) {
            done = true;
        } else {
            inp2 = word2embs([out_string], sos=true);
        }
        
    }

    return out_string.substring(0, out_string.length - 1);
    
}

function word2embs(words, sos=false) {
    n_words = words.length;

    embs_list = [];

    word_length = words[0].length;
    if (sos) {
        word_length += 1;
    }

    for (zx = 0; zx < n_words; zx++) {
        word = words[zx];
        if (word.length != word_length) {
            14/0;
        }
        if (sos) {
            embs_list = embs_list.concat(embedding_dictionary["SOS"]);
        }

        for(i = 0; i < word.length; i++) {
            embs_list = embs_list.concat(embedding_dictionary[word[i]]);
        }
    }
    return tf.tensor3d(embs_list, [n_words,word_length,10]);

}








function embed_seqs(seqs) {
	max_seq_length = 0;
	emb_list = []
	multiplier_list = [];

	for (seqi = 0; seqi < seqs.length; seqi++) {
		this_length = seqs[seqi].length;
		if (this_length > max_seq_length) {
			max_seq_length = this_length;
		}

	}

	for (seqind = 0; seqind < max_seq_length; seqind++) {
		current_emb_list = [];
		current_mult_list = [];

		for (seqk = 0; seqk < seqs.length; seqk++) {
		
			if (seqind < seqs[seqk].length) {
				thischar = seqs[seqk][seqind];
				current_mult_list.push(these_ones.slice());
			} else {
				thischar = "N";
				current_mult_list.push(these_zeros.slice());
			}

			current_emb = embedding_dictionary[thischar];
			current_emb_list = current_emb_list.concat(current_emb);
		}
		emb_list.push(tf.tensor2d(current_emb_list, [seqs.length, 10]));
		multiplier_list.push(tf.tensor2d(current_mult_list, [seqs.length, 256]));
	}

	return [emb_list, multiplier_list];

}

function lst_append(lst, nw) {
	new_lst = [];

	for (lst_ind = 0; lst_ind < lst.length; lst_ind++) {
		new_lst.push(lst[lst_ind] + nw[lst_ind]);
	}

	return new_lst;
}


function seq2seq(inpseqs, outlength=-1) {
	num_seqs = inpseqs.length;

	embs_pair = embed_seqs(inpseqs);
	embs = embs_pair[0];
	mults = embs_pair[1];


	hidden_state = tf.zeros([num_seqs,256]);
	for (qz = 0; qz < embs.length; qz++) {
		inp = embs[qz]; //tf.tensor2d(embedding_dictionary[inpseq[qz]], [1,10]);
		zt = inp.matMul(xz).add(bz).add(hidden_state.matMul(wz)).sigmoid();
		rt = inp.matMul(xr).add(br).add(hidden_state.matMul(wr)).sigmoid();
		urht = rt.mul(hidden_state).matMul(wx).add(bx);
		xt = inp.matMul(xx);
		h_tilde = urht.add(xt).tanh();
		ones = tf.ones([1,256]);
		hidden_state_new = zt.mul(hidden_state).add(ones.sub(zt).mul(h_tilde));

		if (num_seqs > 1) {
			hidden_state = hidden_state_new.mul(mults[qz]).add(hidden_state.mul(ones.sub(mults[qz])));
		} else {
			hidden_state = hidden_state_new;
		}

	}
	prev_output = []; 

	outseq = [];
	for (ns = 0; ns < num_seqs; ns++) {
		prev_output.push("S");
		outseq.push("");
	}
	logits = [];

	if (outlength == -1) {
		max_length = 15;
	} else if (outlength == 0) {
		max_length = 1;
	} else {
		max_length = outlength;
	}
	for (qz = 0; qz < max_length + 1; qz++) {
		inp = embed_seqs(prev_output)[0][0]; //tf.tensor2d(embedding_dictionary[prev_output], [1,10]);
		zt = inp.matMul(xzd).add(bzd).add(hidden_state.matMul(wzd)).sigmoid();
		rt = inp.matMul(xrd).add(brd).add(hidden_state.matMul(wrd)).sigmoid();
		urht = rt.mul(hidden_state).matMul(wxd).add(bxd);
		xt = inp.matMul(xxd);
		h_tilde = urht.add(xt).tanh();
		ones = tf.ones([1,256]);
		hidden_state = zt.mul(hidden_state).add(ones.sub(zt).mul(h_tilde));

		logit = hidden_state.matMul(wout).add(bout);//HEREHERE
		logits = logits.concat(logit);

		topks = tf.topk(logit)["indices"];
    	topks_usable = topks.dataSync();


		prev_output = []; 
		for (zzz = 0; zzz < topks_usable.length; zzz++) {
			prev_output.push(ind2char[topks_usable[zzz]]);
		}

		if (outlength == -1 && prev_output == "Z") {
			break;
		}
		
		outseq = lst_append(outseq, prev_output);
	}


	return [outseq, tf.stack(logits, axis=1)];	

}


function seq2seqb(inpseqs, outlength=-1) {
	num_seqs = inpseqs.length;
	embs_pair = embed_seqs(inpseqs);
    embs = embs_pair[0];
    mults = embs_pair[1];

	outseq = "";
	hidden_state = tf.zeros([num_seqs,256]);
	for (qz = 0; qz < embs.length; qz++) {
		inp = embs[qz]; //tf.tensor2d(embedding_dictionary[inpseq[qz]], [1,10]);
		zt = inp.matMul(xzb).add(bzb).add(hidden_state.matMul(wzb)).sigmoid();
		rt = inp.matMul(xrb).add(brb).add(hidden_state.matMul(wrb)).sigmoid();
		urht = rt.mul(hidden_state).matMul(wxb).add(bxb);
		xt = inp.matMul(xxb);
		h_tilde = urht.add(xt).tanh();
		ones = tf.ones([1,256]);
		hidden_state_new = zt.mul(hidden_state).add(ones.sub(zt).mul(h_tilde));

		if (num_seqs > 1) {
			hidden_state = hidden_state_new.mul(mults[qz]).add(hidden_state.mul(ones.sub(mults[qz])));
		} else {
			hidden_state = hidden_state_new;
		}

	}

	prev_output = [];
	outseq = [];

	for (ns = 0; ns < num_seqs; ns++) {
		prev_output.push("S");
		outseq.push("");
	}


	logits = [];

	if (outlength == -1) {
		max_length = 15;
	} else if (outlength == 0) {
		max_length = 1;
	} else {
		max_length = outlength;
	}
	for (qz = 0; qz < max_length + 1; qz++) {
		inp = embed_seqs(prev_output)[0][0]; //tf.tensor2d(embedding_dictionary[prev_output], [1,10]);

		zt = inp.matMul(xzdb).add(bzdb).add(hidden_state.matMul(wzdb)).sigmoid();
		rt = inp.matMul(xrdb).add(brdb).add(hidden_state.matMul(wrdb)).sigmoid();
		urht = rt.mul(hidden_state).matMul(wxdb).add(bxdb);
		xt = inp.matMul(xxdb);
		h_tilde = urht.add(xt).tanh();
		ones = tf.ones([1,256]);
		hidden_state = zt.mul(hidden_state).add(ones.sub(zt).mul(h_tilde));

		logit = hidden_state.matMul(woutb).add(boutb);//HEREHERE
		logits = logits.concat(logit);

		topks = tf.topk(logit)["indices"];
    	topks_usable = topks.dataSync();

		prev_output = [];
		for (zzz = 0; zzz < topks_usable.length; zzz++) {
			prev_output.push(ind2char[topks_usable[zzz]]);
		}

		if (outlength == -1 && prev_output == "Z") {
			break;
		}

		outseq = lst_append(outseq, prev_output);
	}


	return [outseq, tf.stack(logits, axis=1)];	

}







var xsm = training_set[0][0];
var ysm = training_set[0][1];



function* data() {
 for (let i = 0; i < 1; i++) {
   // Generate one sample at a time.
   yield "attt";
 }
}

function* labels() {
 for (let i = 0; i < 1; i++) {
   // Generate one sample at a time.
   yield ".a.";
 }
}



//const xsa = tf.data.generator(data);
//const ysa = tf.data.generator(labels);
// Zip the data and labels together, shuffle and batch 32 samples at a time.
//const dsa = tf.data.zip({xsa, ysa}).shuffle(100 /* bufferSize */).batch(32);

const xsma = tf.data.generator(data);
const ysma = tf.data.generator(labels);
const ds = tf.data.zip({xsma, ysma}).shuffle(100).batch(1);

function return_inps() {
	return xs, ys;
}

document.getElementById("printplacec").innerHTML = "dog";


async function fitfitfitfirst(seq2seq, prefix, add_train=false) {


const optimizer = tf.train.sgd(0.05);
// Train for 5 epochs.
for (let epoch = 0; epoch < 1; epoch++) {
  await ds.forEachAsync(({xs, ys}) => {
    optimizer.minimize(() => {
	  if (add_train) {
	  	xsm = training_set[this_counter][0];
		ysm = training_set[this_counter][1];
		seen_training = seen_training + nullify(xsm) + " &rarr; " + nullify(ysm) + "<br>";
		console.log("tc", this_counter);
	  	this_counter += 1;
		if (this_counter > training_set.length - 1) {
			document.getElementById("oneexamplebtn").disabled = true;
		}
		document.getElementById("traincount").innerHTML = this_counter - 1;
	  }
      const predYs = tf.tidy(() => seq2seq([xsm],outlength=ysm.length)[1]);
	  
      const loss = tf.losses.softmaxCrossEntropy(make_one_hot_seq(ysm), predYs, axis=1);
      loss.data().then(l => console.log('Loss', l));

      return loss;
    });
  });

  console.log('Epoch', epoch);
}


}

function update_display(seq2seq, prefix) {

  preds = tf.tidy(() => seq2seq(test_set_firsts)[0]);
  for (lmnop = 0; lmnop < test_set.length; lmnop++) {
	pred = toz(preds[lmnop]);
 	if (pred == test_set[lmnop][1]) {
    	font_color = "green";
    } else {
    	font_color = "red";
    }
			
	document.getElementById(prefix + "outb" + (lmnop + 1)).innerHTML = "<span style='color: " + font_color + ";'>" + nullify(pred) + "</span>";
	console.log("here we are everyone!!!");
  }

	  	document.getElementById("trainingexamplelist").innerHTML = seen_training;
		document.getElementById("trainingexamplelist").scrollTop = document.getElementById("trainingexamplelist").scrollHeight;


		document.getElementById("traincount").innerHTML = this_counter;



}
async function fitfitfit(seq2seq, prefix, add_train=false) {
setTimeout(async function () {
	//update_display(seq2seq, prefix);
const optimizer = tf.train.sgd(0.05);
// Train for 5 epochs.
for (let epoch = 0; epoch < 1; epoch++) {


  await ds.forEachAsync(({xs, ys}) => {

  preds = tf.tidy(() => seq2seq(test_set_firsts)[0]);
  seen_training_prime = seen_training;
    optimizer.minimize(() => {
	  if (add_train) {
	  	xsm = training_set[this_counter][0];
		ysm = training_set[this_counter][1];
		seen_training = seen_training + nullify(xsm) + " &rarr; " + nullify(ysm) + "<br>";
		console.log("tc", this_counter);
	  	this_counter += 1;
		if (this_counter > training_set.length - 1) {
			document.getElementById("oneexamplebtn").disabled = true;
		}
	  }
      const predYs = tf.tidy(() => seq2seq([xsm],outlength=ysm.length)[1]);
	  
      const loss = tf.losses.softmaxCrossEntropy(make_one_hot_seq(ysm), predYs, axis=1);
      loss.data().then(l => console.log('Loss', l));


      return loss;
    });


  for (lmnop = 0; lmnop < test_set.length; lmnop++) {
	pred = toz(preds[lmnop]);
 	if (pred == test_set[lmnop][1]) {
    	font_color = "green";
    } else {
    	font_color = "red";
    }
			
	document.getElementById(prefix + "outb" + (lmnop + 1)).innerHTML = "<span style='color: " + font_color + ";'>" + nullify(pred) + "</span>";
	console.log("here we are everyone!!!");
  }

	if (add_train) {
	  	document.getElementById("trainingexamplelist").innerHTML = seen_training_prime;
		document.getElementById("trainingexamplelist").scrollTop = document.getElementById("trainingexamplelist").scrollHeight;


		document.getElementById("traincount").innerHTML = this_counter - 1;
	}


  });

  console.log('Epoch', epoch);
}

}, 1);


}




	  console.log("tfs", test_set_firsts);
	  preds = tf.tidy(() => seq2seq(test_set_firsts)[0]);
	  for (lmnop = 0; lmnop < test_set.length; lmnop++) {
			pred = toz(preds[lmnop])
			if (pred == test_set[lmnop][1]) {
				font_color = "green";
			} else {
				font_color = "red";
			}
			document.getElementById("metaoutb" + (lmnop + 1)).innerHTML = "<span style='color: " + font_color + ";'>" + nullify(pred) + "</span>";
	  }


	  preds = tf.tidy(() => seq2seqb(test_set_firsts)[0]);
	  for (lmnop = 0; lmnop < test_set.length; lmnop++) {
			pred = toz(preds[lmnop]);
			if (pred == test_set[lmnop][1]) {
                font_color = "green";
            } else {
                font_color = "red";
            }


			document.getElementById("randomoutb" + (lmnop + 1)).innerHTML = "<span style='color: " + font_color + ";'>" + nullify(pred) + "</span>";
	  }


renew_language();

document.getElementById("rankbtn").innerHTML = key2ranking[manual_ranking];
document.getElementById("langdesc").innerHTML = key2description[new_lang[5]].replace("CONS", new_lang[4][0]).replace("VOW", new_lang[3][0]);


/* When the user clicks on the button,
toggle between hiding and showing the dropdown content */
function dropFunction() {
  document.getElementById("myDropdown").classList.toggle("show");
}

// Close the dropdown menu if the user clicks outside of it
window.onclick = function(event) {
  if (!event.target.matches('.dropbtn')) {
    var dropdowns = document.getElementsByClassName("dropdown-content");
    var i;
    for (i = 0; i < dropdowns.length; i++) {
      var openDropdown = dropdowns[i];
      if (openDropdown.classList.contains('show')) {
        openDropdown.classList.remove('show');
      }
    }
  }
}


function drawStar(centerX, centerY, points, outer, inner, fill, stroke, line) {
    // define the star
    ctx.beginPath();
    ctx.moveTo(centerX, centerY+outer);
    for (var i=0; i < 2*points+1; i++) {
        var r = (i%2 == 0)? outer : inner;
        var a = Math.PI * i/points;
        ctx.lineTo(centerX + r*Math.sin(a), centerY + r*Math.cos(a));
    };
    ctx.closePath();
    // draw
    ctx.fillStyle=fill;
    ctx.fill();
    ctx.strokeStyle=stroke;
    ctx.lineWidth=line;
    ctx.stroke()
}

var canvas = document.getElementById("myCanvas");
var ctx = canvas.getContext("2d");
ctx.moveTo(0, 150);
ctx.lineTo(300, 150);
ctx.stroke();

ctx.moveTo(150, 0);
ctx.lineTo(150, 300);
ctx.stroke();
ctx.beginPath();
ctx.arc(60, 210, 30, 0, 2 * Math.PI);
ctx.stroke();

ctx.fillRect(240,90,3,3)
drawStar(240, 90, 5, 10, 5, 'mediumseagreen','gray',1);

function loss(m,b,x1,x2,y1,y2,r) {
	l1 = m * x2 + 2*r*x1*y1*x2 - 2*r*(x1*x1)*m*x2 - 2*r*b*x1*x2 + b + 2*r*y1 - 2*r*m*x1 - 2*r*b - y2;
	
	dldm = 2*l1 * (x2 - 2*r*(x1*x1)*x2 - 2*r*x1);
	dldb = 2*l1*(-2*r*x1*x2 + 1 - 2*r);

	return [dldm, dldb];

}


function loss_non_meta(m,b,x,y) {
	dldm = -2*x*y + 2*x*x*m + 2*b*x;
	dldb = -2*y + 2*m*x + 2*b;

	return [dldm, dldb];
}


var slope = 3;
var intercept = 2;
var rinner = 0.5;
var router = 0.01;

demo_ind = 0;

function myLoop() {

	setTimeout(function () {
	randnum = 2 * Math.PI * Math.random();
	mcorr = Math.cos(randnum) - 3;
	bcorr = Math.sin(randnum) -2;
	//bcorr = Math.sqrt((1.0 - randnum*randnum)) - 2;
	
	cointoss = choice([0,1]);
	if (cointoss == 0) {
		bcorr = -1 * (bcorr + 4);
	}

	x1 = 2 * Math.random() - 1;
	x2 = 2 * Math.random() - 1;
	x3 = 2 * Math.random() - 1; //

	y1 = mcorr*x1 + bcorr;
	y2 = mcorr*x2 + bcorr;
	y3 = mcorr*x3 + bcorr; //

	losses = loss(slope, intercept, x1, x2, y1, y2, rinner);
	dldm = losses[0];
	dldb = losses[1];

	inner_losses = loss_non_meta(slope,intercept,x1,y1);
	dldmi = inner_losses[0];
	dldbi = inner_losses[1];

	for (qinn = 0; qinn < 10; qinn++) {	
		x3 = 2 * Math.random() - 1;
		y3 = mcorr*x3 + bcorr;

		inner_losses_b = loss_non_meta(slope,intercept,x3,y3);
		dldmi = dldmi + inner_losses_b[0];
		dldbi = dldbi + inner_losses_b[1];

		losses_b = loss(slope, intercept, x3, x2, y3, y2, rinner);
		dldm = dldm + losses_b[0];
		dldb = dldb + losses_b[1];
	}

	dldmi = dldmi/11;
	dldbi = dldbi/11;

	slopenew = slope - router*dldm;
	interceptnew = intercept - router*dldb;

	slopenewb = slope - rinner*dldmi;
	interceptnewb = intercept - rinner*dldbi;


	ctx.clearRect(0, 0, canvas.width, canvas.height);
	ctx.font = "12px Arial";
	ctx.fillStyle="black";
	ctx.fillText("Parameter 2", 120, 20);	
	ctx.fillText("Parameter 1", 10, 145); 
	
	drawStar(30*mcorr+150, -30*bcorr+150, 5, 2, 5, 'purple','gray',0);
	
	ctx.moveTo(0, 150);
	ctx.lineTo(300, 150);
	ctx.stroke();

	ctx.moveTo(150, 0);
	ctx.lineTo(150, 300);
	ctx.stroke();

	ctx.beginPath();
	ctx.arc(60, 210, 30, 0, 2 * Math.PI);
	ctx.stroke();
	drawStar(30*slope+150, -30*intercept+150, 5, 2, 5, 'mediumseagreen','gray',0);

	
	setTimeout(function () {


		drawStar(30*slopenewb+150, -30*interceptnewb+150, 5, 2, 5, 'orange','gray',0);
		ctx.moveTo(30*slope+150, -30*intercept+150);
		ctx.lineTo(30*slopenewb+150, -30*interceptnewb+150);
		ctx.stroke();


		setTimeout(function () {

			slope = slopenew;
			intercept = interceptnew;

			ctx.clearRect(0, 0, canvas.width, canvas.height);
			ctx.font = "12px Arial";
			ctx.fillStyle="black";
			ctx.fillText("Parameter 2", 120, 20);	
			ctx.fillText("Parameter 1", 10, 145); 
			drawStar(30*mcorr+150, -30*bcorr+150, 5, 2, 5, 'purple','gray',0);	
			drawStar(30*slopenewb+150, -30*interceptnewb+150, 5, 2, 5, 'orange','gray',0);
			ctx.moveTo(30*slope+150, -30*intercept+150);
			ctx.lineTo(30*slopenewb+150, -30*interceptnewb+150);
			ctx.stroke();


			drawStar(30*slope+150, -30*intercept+150, 5, 2, 5, 'mediumseagreen','gray',0);
			ctx.moveTo(0, 150);
			ctx.lineTo(300, 150);
			ctx.stroke();

			ctx.moveTo(150, 0);
			ctx.lineTo(150, 300);
			ctx.stroke();

			ctx.beginPath();
			ctx.arc(60, 210, 30, 0, 2 * Math.PI);
			ctx.stroke();
			demo_ind++;
	
			if (demo_ind < 10000) {
				myLoop();
			}
		}, 2000/(Math.pow(2, pace)))

	}, 2000/(Math.pow(2, pace)))

	}, 800/(Math.pow(2, pace)))
}
var pace = 1;
myLoop();


console.log(slope, intercept);

var slider = document.getElementById("myRange");
var output = document.getElementById("demo");
slider.value = 1;
output.innerHTML = slider.value; // Display the default slider value

// Update the current slider value (each time you drag the slider handle)
slider.oninput = function() {
  output.innerHTML = this.value;
  pace = Math.sqrt(this.value);
}


</script>


</body>



</html>


